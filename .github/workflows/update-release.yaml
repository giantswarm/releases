name: Update Release PR (Comment Trigger)

on:
  issue_comment:
    types: [created]

jobs:
  update-release:
    # This job only runs for pull request comments
    if: github.event.issue.pull_request && (startsWith(github.event.comment.body, '/update-release') || startsWith(github.event.comment.body, '/update-readme') || startsWith(github.event.comment.body, '/update-announcement')) && github.repository == 'giantswarm/releases' && github.event.sender.login != 'taylorbot'
    runs-on: ubuntu-latest
    env:
      OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Add reaction to comment to indicate that the bot is working on the update
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: 'eyes'
            })

      - name: Get PR branch name
        id: get_branch
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          result-encoding: string
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.issue.number }}
            });
            return pr.data.head.ref;

      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.get_branch.outputs.result }}

      - name: Install devctl from release binary
        run: |
          mkdir -p /tmp/devctl_install
          cd /tmp/devctl_install
          LATEST_DEVCTL_TAG=$(gh release view --repo giantswarm/devctl --json tagName --jq '.tagName')
          ASSET_NAME="devctl-${LATEST_DEVCTL_TAG}-linux-amd64.tar.gz"
          gh release download --repo giantswarm/devctl "$LATEST_DEVCTL_TAG" --pattern "$ASSET_NAME"
          tar -xzf "$ASSET_NAME"
          find . -name "devctl" -type f -exec sudo mv {} /usr/local/bin/devctl \;
          cd -
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Parse command arguments and determine provider(s)
        id: parse_command
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Use printf to safely handle quotes and special characters
          printf '%s\n' "$COMMENT_BODY" > /tmp/comment_body.txt

          # Check if this is a description-only update
          COMMENT_CONTENT=$(cat /tmp/comment_body.txt)
          if [[ "$COMMENT_CONTENT" == *"/update-readme"* ]]; then
            echo "description_only=true" >> "$GITHUB_OUTPUT"
            echo "update_type=readme" >> "$GITHUB_OUTPUT"
            # Extract description safely from file
            if [[ "$COMMENT_CONTENT" == *"--provider"* ]]; then
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|.*--provider[= ]+[a-zA-Z-]+ +||' | sed 's/^"//' | sed 's/"$//')
            else
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|/update-readme +||' | sed 's/^"//' | sed 's/"$//')
            fi
            # Use base64 encoding to safely pass description with special characters
            echo "description=$(echo "$DESCRIPTION" | base64 -w 0)" >> "$GITHUB_OUTPUT"
            DEVCTL_ARGS=""
          elif [[ "$COMMENT_CONTENT" == *"/update-announcement"* ]]; then
            echo "description_only=true" >> "$GITHUB_OUTPUT"
            echo "update_type=announcement" >> "$GITHUB_OUTPUT"
            # Extract description safely from file
            if [[ "$COMMENT_CONTENT" == *"--provider"* ]]; then
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|.*--provider[= ]+[a-zA-Z-]+ +||' | sed 's/^"//' | sed 's/"$//')
            else
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|/update-announcement +||' | sed 's/^"//' | sed 's/"$//')
            fi
            # Use base64 encoding to safely pass description with special characters
            echo "description=$(echo "$DESCRIPTION" | base64 -w 0)" >> "$GITHUB_OUTPUT"
            DEVCTL_ARGS=""
          else
            echo "description_only=false" >> "$GITHUB_OUTPUT"
            # Extract devctl arguments, excluding the /update-release command and any --provider flag
            DEVCTL_ARGS=$(echo "$COMMENT_CONTENT" | sed -E 's|/update-release||; s/--provider[= ]+[a-zA-Z-]+//' | xargs)
          fi
          echo "devctl_args=$DEVCTL_ARGS" >> "$GITHUB_OUTPUT"

          # Check for --provider in the comment
          COMMENT_PROVIDER=$(echo "$COMMENT_BODY" | grep -oP '(?<=--provider(=| ))[a-zA-Z-]+' || true)

          if [[ -n "$COMMENT_PROVIDER" ]]; then
            echo "Provider specified in comment: $COMMENT_PROVIDER"
            echo "provider=$COMMENT_PROVIDER" >> "$GITHUB_OUTPUT"
          else
            echo "No provider specified. Detecting providers from PR files."
            # Get providers from the PR's changed files.
            PR_PROVIDERS=$(gh pr view ${{ github.event.issue.number }} --json files --jq '.files[].path' | cut -d'/' -f1 | sort -u | xargs)
            # List of valid provider directories.
            VALID_PROVIDERS="azure capa cloud-director vsphere"
            PROVIDERS_LIST=""
            for provider in $PR_PROVIDERS; do
              if [[ " $VALID_PROVIDERS " =~ " $provider " ]]; then
                PROVIDERS_LIST="$PROVIDERS_LIST $provider"
              fi
            done
            # Trim leading/trailing whitespace.
            PROVIDERS_LIST=$(echo "$PROVIDERS_LIST" | xargs)
            if [[ -z "$PROVIDERS_LIST" ]]; then
              echo "Could not determine any providers from the PR files."
            fi
            echo "Detected providers: $PROVIDERS_LIST"
            echo "providers_list=${PROVIDERS_LIST}" >> "$GITHUB_OUTPUT"
          fi

      - name: Update documentation
        id: update_docs
        if: success() && steps.parse_command.outputs.description_only == 'true' && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDERS_TO_UPDATE="${{ steps.parse_command.outputs.provider }}${{ steps.parse_command.outputs.providers_list }}"
          DESCRIPTION_B64="${{ steps.parse_command.outputs.description }}"
          UPDATE_TYPE="${{ steps.parse_command.outputs.update_type }}"
          
          # Decode description from base64
          DESCRIPTION=$(echo "$DESCRIPTION_B64" | base64 -d)
          
          # For `devctl`, the provider for the `capa` directory is `aws`.
          if [[ " ${PROVIDERS_TO_UPDATE} " =~ " aws " ]]; then
            PROVIDERS_TO_UPDATE=$(echo "${PROVIDERS_TO_UPDATE}" | sed 's/aws/capa/g')
          fi

          # Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          if [[ -z "$RELEASE_NAME" ]]; then
            echo "Could not determine release name from branch '$BRANCH_NAME'. Aborting."
            exit 1
          fi

          FULL_LOG_CONTENT=""

          for PROVIDER in $PROVIDERS_TO_UPDATE; do
            PROVIDER_DIR=$PROVIDER
            echo "Updating $UPDATE_TYPE for provider: $PROVIDER_DIR"

            # Check if release directory exists
            if [ ! -d "$PROVIDER_DIR/$RELEASE_NAME" ]; then
              echo "Release '$RELEASE_NAME' does not exist for provider '$PROVIDER_DIR'. Skipping."
              continue
            fi

            if [[ "$UPDATE_TYPE" == "readme" ]]; then
              # Update README.md
              README_FILE="$PROVIDER_DIR/$RELEASE_NAME/README.md"
              if [ -f "$README_FILE" ]; then
                # Backup the entire README.md content before making changes
                README_BACKUP=$(cat "$README_FILE")
                
                if grep -q "<< Add description here >>" "$README_FILE"; then
                  # Replace placeholder
                  sed -i "s/<< Add description here >>/$DESCRIPTION/g" "$README_FILE"
                  echo "Added description to README.md"
                else
                  # Replace the warning/description section (line 3, after title and blank line)
                  sed -i "3c\\$DESCRIPTION" "$README_FILE"
                  echo "Updated existing description in README.md"
                fi
                
                # Verify the change was made correctly and restore if needed
                if ! grep -q "$DESCRIPTION" "$README_FILE"; then
                  echo "Description update failed, restoring original content"
                  echo "$README_BACKUP" > "$README_FILE"
                fi
              fi
              LOG_PART="### README updated for ${PROVIDER_DIR^^}\n\n"
              LOG_PART="${LOG_PART}üìù **README Description**: $DESCRIPTION\n\n"
            
            elif [[ "$UPDATE_TYPE" == "announcement" ]]; then
              # Update announcement.md
              ANNOUNCEMENT_FILE="$PROVIDER_DIR/$RELEASE_NAME/announcement.md"
              if [ -f "$ANNOUNCEMENT_FILE" ]; then
                # Determine provider name
                PROVIDER_NAME=""
                if [[ "$PROVIDER_DIR" == "capa" ]]; then
                  PROVIDER_NAME="CAPA"
                elif [[ "$PROVIDER_DIR" == "azure" ]]; then
                  PROVIDER_NAME="Azure"
                elif [[ "$PROVIDER_DIR" == "vsphere" ]]; then
                  PROVIDER_NAME="vSphere"
                elif [[ "$PROVIDER_DIR" == "cloud-director" ]]; then
                  PROVIDER_NAME="VMware Cloud Director"
                else
                  PROVIDER_NAME=$(echo "$PROVIDER_DIR" | tr 'a-z' 'A-Z')
                fi
                
                # Always recreate line 1 with the proper format
                RELEASE_VERSION=$(echo "$RELEASE_NAME" | sed 's/v//')
                NEW_LINE_1="**Workload cluster release v${RELEASE_VERSION} for ${PROVIDER_NAME} is available**. $DESCRIPTION"
                
                # Replace line 1 completely
                sed -i "1c\\$NEW_LINE_1" "$ANNOUNCEMENT_FILE"
                echo "Updated announcement.md with new description"
              fi
              LOG_PART="### Announcement updated for ${PROVIDER_DIR^^}\n\n"
              LOG_PART="${LOG_PART}üì¢ **Announcement**: $DESCRIPTION\n\n"
            fi

            FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
          done

          # Replace literal '\n' with actual newlines for proper rendering in the GitHub comment.
          FULL_LOG_CONTENT=$(printf '%b' "${FULL_LOG_CONTENT}")
          echo "DEVCTL_OUTPUT_COMMENT<<EOF" >> "$GITHUB_ENV"
          echo "$FULL_LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Recreate release files
        id: recreate_release
        if: success() && steps.parse_command.outputs.description_only != 'true' && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          set -o pipefail
          export DEVCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDERS_TO_UPDATE="${{ steps.parse_command.outputs.provider }}${{ steps.parse_command.outputs.providers_list }}"
          
          # For `devctl`, the provider for the `capa` directory is `aws`.
          # We must translate `aws` to `capa` for directory lookups.
          if [[ " ${PROVIDERS_TO_UPDATE} " =~ " aws " ]]; then
            PROVIDERS_TO_UPDATE=$(echo "${PROVIDERS_TO_UPDATE}" | sed 's/aws/capa/g')
          fi

          # 1. Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          if [[ -z "$RELEASE_NAME" ]]; then
            echo "Could not determine release name from branch '$BRANCH_NAME'. Aborting."
            exit 1
          fi

          FULL_LOG_CONTENT=""

          for PROVIDER in $PROVIDERS_TO_UPDATE; do
            PROVIDER_DIR=$PROVIDER
            echo "Processing provider: $PROVIDER_DIR"

            # For `devctl`, the provider for the `capa` directory is `aws`.
            if [ "$PROVIDER" == "capa" ]; then
                PROVIDER="aws"
            fi

            # Check if release directory for the given release name exists for the provider in the current branch
            if [ ! -d "$PROVIDER_DIR/$RELEASE_NAME" ]; then
              echo "Release '$RELEASE_NAME' does not exist for provider '$PROVIDER_DIR' (in directory '$PROVIDER_DIR'). Skipping."
              continue
            fi

            echo "Updating release '$RELEASE_NAME' for provider '$PROVIDER_DIR'"

            # 3. Determine the base release from the README.md
            BASE_RELEASE=""
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/README.md" ]; then
              # Extract base release from "## Changes compared to vX.Y.Z" line
              BASE_RELEASE=$(grep -oP '## Changes compared to \Kv[0-9]+\.[0-9]+\.[0-9]+' "${PROVIDER_DIR}/${RELEASE_NAME}/README.md" || true)
            fi
            
            # 4. Recreate the release
            DEVCTL_ARGS="${{ steps.parse_command.outputs.devctl_args }}"
            
            # By default, we only bump all components if no specific app/component is requested.
            if [[ "$DEVCTL_ARGS" == *--app* || "$DEVCTL_ARGS" == *--component* ]]; then
              echo "Specific app/component version requested."
              
              # Extract app/component names for changelog extraction
              REQUESTED_APPS=$(echo "$DEVCTL_ARGS" | grep -oP '(?<=--app )[^ @]+' || true)
              REQUESTED_COMPONENTS=$(echo "$DEVCTL_ARGS" | grep -oP '(?<=--component )[^ @]+' || true)
              
              if [[ -n "$BASE_RELEASE" ]]; then
                echo "Using base release: $BASE_RELEASE to generate changelog"
                
                # Backup release.yaml before temp devctl overwrites it
                if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
                  cp "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" /tmp/release.yaml.backup
                fi
                
                # Step 1: Generate temporary README with changelogs using --base and --bumpall
                echo "Generating temporary README with changelogs..."
                devctl release create --base "$BASE_RELEASE" --name "$RELEASE_NAME" --provider "$PROVIDER" --bumpall --overwrite -y --output markdown $DEVCTL_ARGS > /dev/null 2>&1 || true
                
                # Step 2: Extract changelog sections for requested apps/components
                TEMP_README="${PROVIDER_DIR}/${RELEASE_NAME}/README.md"
                CHANGELOG_CONTENT=""
                
                for APP in $REQUESTED_APPS; do
                  echo "Extracting changelog for app: $APP"
                  # Extract the changelog section (from ### app-name to next ### or end)
                  CHANGELOG_SECTION=$(awk "/^### $APP \[/,/^### [^#]/ {if (/^### [^#]/ && !/^### $APP \[/) exit; print}" "$TEMP_README" || true)
                  if [ -n "$CHANGELOG_SECTION" ]; then
                    CHANGELOG_CONTENT="${CHANGELOG_CONTENT}${CHANGELOG_SECTION}\n\n"
                  fi
                done
                
                for COMP in $REQUESTED_COMPONENTS; do
                  echo "Extracting changelog for component: $COMP"
                  CHANGELOG_SECTION=$(awk "/^### $COMP \[/,/^### [^#]/ {if (/^### [^#]/ && !/^### $COMP \[/) exit; print}" "$TEMP_README" || true)
                  if [ -n "$CHANGELOG_SECTION" ]; then
                    CHANGELOG_CONTENT="${CHANGELOG_CONTENT}${CHANGELOG_SECTION}\n\n"
                  fi
                done
                
                # Save changelog content for later injection
                echo "$CHANGELOG_CONTENT" > /tmp/changelog_inject.txt
                
                # Restore original release.yaml before running final devctl
                if [ -f /tmp/release.yaml.backup ]; then
                  cp /tmp/release.yaml.backup "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml"
                  echo "Restored original release.yaml"
                fi
              fi
              
              # Step 3: Run devctl with --update-existing to only update release.yaml
              echo "Updating release.yaml with requested changes..."
              DEVCTL_COMMAND="devctl release create --name \"$RELEASE_NAME\" --provider \"$PROVIDER\" --overwrite -y --output markdown --requested-only --update-existing $DEVCTL_ARGS"
            else
              echo "No specific app/component version requested, bumping all."
              DEVCTL_COMMAND="devctl release create --name \"$RELEASE_NAME\" --provider \"$PROVIDER\" --overwrite -y --output markdown --requested-only --update-existing --bumpall $DEVCTL_ARGS"
            fi

            echo "Running command: $DEVCTL_COMMAND"
            
            # Check for changes before running the command
            BEFORE_HASH=""
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
              BEFORE_HASH=$(sha256sum "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" | cut -d' ' -f1)
            fi
            
            # Backup existing descriptions before devctl overwrites them
            README_DESCRIPTION_BACKUP=""
            ANNOUNCEMENT_BACKUP=""
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/README.md" ] && ! grep -q "<< Add description here >>" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"; then
              # Extract existing README description (line 3, which is the warning/description)
              README_DESCRIPTION_BACKUP=$(sed -n '3p' "${PROVIDER_DIR}/${RELEASE_NAME}/README.md" || true)
            fi
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md" ] && ! grep -q "<< Add description here >>" "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md"; then
              # Extract existing announcement description (everything after "**. ")
              ANNOUNCEMENT_BACKUP=$(sed -n '1p' "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md" | sed 's/.*\*\*\. //' || true)
            fi
            
            if ! output=$(eval "$DEVCTL_COMMAND" 2>&1 | uniq); then
                LOG_PART="### User-requested changes for ${PROVIDER_DIR^^}\n\n"
                LOG_PART="${LOG_PART}devctl command failed for provider $PROVIDER_DIR.\n\n"
                LOG_PART="${LOG_PART}<details><summary>Error Log</summary>\n\n"
                LOG_PART="${LOG_PART}_Output of \`devctl release create\`_: \n"
                LOG_PART="${LOG_PART}\`\`\`\n${output}\n\`\`\`\n\n"
                LOG_PART="${LOG_PART}</details>\n\n"
                FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
            else
                LOG_PART="### User-requested changes for ${PROVIDER_DIR^^}\n\n"
                
                # Check if files actually changed
                AFTER_HASH=""
                if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
                  AFTER_HASH=$(sha256sum "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" | cut -d' ' -f1)
                fi
                
                # Determine if changes were made
                if [[ "$BEFORE_HASH" != "$AFTER_HASH" ]]; then
                  # Files changed, show what was requested
                  if [[ -z "$(echo -e "${output}" | tr -d '[:space:]')" ]]; then
                    # Generate a table showing what changed
                    CHANGES_TABLE=""
                    
                    # Parse the requested changes and show them in table format
                    if [[ "$DEVCTL_ARGS" == *--app* ]]; then
                      CHANGES_TABLE="${CHANGES_TABLE}| APP NAME | DESIRED APP VERSION |\n"
                      CHANGES_TABLE="${CHANGES_TABLE}|----------|--------------------|\n"
                      
                      # Extract app changes from the arguments
                      APP_SPECS=$(echo "$DEVCTL_ARGS" | grep -oE '\--app [^ ]+' | sed 's/--app //')
                      for app_spec in $APP_SPECS; do
                        if [[ "$app_spec" == *@* ]]; then
                          app_name=$(echo "$app_spec" | cut -d'@' -f1)
                          app_version=$(echo "$app_spec" | cut -d'@' -f2)
                          CHANGES_TABLE="${CHANGES_TABLE}| $app_name | **$app_version** |\n"
                        fi
                      done
                    fi
                    
                    if [[ "$DEVCTL_ARGS" == *--component* ]]; then
                      if [[ -n "$CHANGES_TABLE" ]]; then
                        CHANGES_TABLE="${CHANGES_TABLE}\n"
                      fi
                      CHANGES_TABLE="${CHANGES_TABLE}| COMPONENT NAME | DESIRED VERSION |\n"
                      CHANGES_TABLE="${CHANGES_TABLE}|----------------|----------------|\n"
                      
                      # Extract component changes from the arguments
                      COMP_SPECS=$(echo "$DEVCTL_ARGS" | grep -oE '\--component [^ ]+' | sed 's/--component //')
                      for comp_spec in $COMP_SPECS; do
                        if [[ "$comp_spec" == *@* ]]; then
                          comp_name=$(echo "$comp_spec" | cut -d'@' -f1)
                          comp_version=$(echo "$comp_spec" | cut -d'@' -f2)
                          CHANGES_TABLE="${CHANGES_TABLE}| $comp_name | **$comp_version** |\n"
                        fi
                      done
                    fi
                    
                    if [[ -n "$CHANGES_TABLE" ]]; then
                      LOG_PART="${LOG_PART}${CHANGES_TABLE}\n"
                    else
                      LOG_PART="${LOG_PART}‚úÖ Changes applied successfully.\n\n"
                    fi
                  else
                    LOG_PART="${LOG_PART}${output}\n\n"
                  fi
                else
                  # No changes detected
                  LOG_PART="${LOG_PART}No changes detected for provider ${PROVIDER_DIR^^}. The requested app/component versions may already be present in the current release.\n\n"
                fi
                FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
            fi
            
            # Restore README description if it existed before devctl overwrote it
            if [[ -n "$README_DESCRIPTION_BACKUP" ]]; then
              sed -i "3c\\$README_DESCRIPTION_BACKUP" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"
              echo "Restored description in README.md"
            fi
            
            # Inject changelog content if we extracted it earlier
            if [ -f /tmp/changelog_inject.txt ] && [ -s /tmp/changelog_inject.txt ]; then
              echo "Injecting changelog content into README.md..."
              CHANGELOG_TO_INJECT=$(cat /tmp/changelog_inject.txt)
              
              # Update app/component list in README.md
              for APP in $REQUESTED_APPS; do
                # Extract new version line from changelog
                NEW_APP_LINE=$(echo "$CHANGELOG_TO_INJECT" | grep "^- $APP from" || true)
                if [ -n "$NEW_APP_LINE" ]; then
                  if grep -q "^- $APP from" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"; then
                    # Update existing line
                    sed -i "/^- $APP from/c\\$NEW_APP_LINE" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"
                  else
                    # Add new line after the last app line
                    LAST_APP_LINE=$(grep -n "^- .* from v" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md" | tail -1 | cut -d: -f1)
                    if [ -n "$LAST_APP_LINE" ]; then
                      sed -i "${LAST_APP_LINE}a\\$NEW_APP_LINE" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"
                    fi
                  fi
                fi
              done
              
              # Append changelog sections at the end of README.md
              echo "" >> "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"
              printf '%b' "$CHANGELOG_TO_INJECT" >> "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"
              
              # Clean up
              rm -f /tmp/changelog_inject.txt
              echo "Changelog injected successfully"
            fi
            if [[ -n "$ANNOUNCEMENT_BACKUP" ]]; then
              # Determine provider name for restore
              PROVIDER_NAME=""
              if [[ "$PROVIDER_DIR" == "capa" ]]; then
                PROVIDER_NAME="CAPA"
              elif [[ "$PROVIDER_DIR" == "azure" ]]; then
                PROVIDER_NAME="Azure"
              elif [[ "$PROVIDER_DIR" == "vsphere" ]]; then
                PROVIDER_NAME="vSphere"
              elif [[ "$PROVIDER_DIR" == "cloud-director" ]]; then
                PROVIDER_NAME="VMware Cloud Director"
              else
                PROVIDER_NAME=$(echo "$PROVIDER_DIR" | tr 'a-z' 'A-Z')
              fi
              
              # Recreate line 1 with proper format when restoring
              RELEASE_VERSION=$(echo "$RELEASE_NAME" | sed 's/v//')
              NEW_LINE_1="**Workload cluster release v${RELEASE_VERSION} for ${PROVIDER_NAME} is available**. $ANNOUNCEMENT_BACKUP"
              sed -i "1c\\$NEW_LINE_1" "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md"
              echo "Restored description in announcement.md"
            fi
          done

          # Replace literal '\n' with actual newlines for proper rendering in the GitHub comment.
          FULL_LOG_CONTENT=$(printf '%b' "${FULL_LOG_CONTENT}")

          # Use GITHUB_ENV to avoid issues with special characters in output strings.
          echo "DEVCTL_OUTPUT_COMMENT<<EOF" >> "$GITHUB_ENV"
          echo "$FULL_LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Commit and push changes
        if: success() && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email '41898282+github-actions[bot]@users.noreply.github.com'
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: Update release files via comment"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Add success reaction
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: '+1'
            })
      - name: Post devctl output as a comment
        if: env.DEVCTL_OUTPUT_COMMENT != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = process.env.DEVCTL_OUTPUT_COMMENT;
            github.rest.issues.createComment({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });
