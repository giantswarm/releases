name: Update Release PR (Comment Trigger)

on:
  repository_dispatch:
    types: [update-release-triggered]

jobs:
  update-release:
    runs-on: ubuntu-latest
    env:
      OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Add reaction to comment to indicate that the bot is working on the update
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.client_payload.comment.id }},
              content: 'eyes'
            })

      - name: Get PR branch name
        id: get_branch
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          result-encoding: string
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.client_payload.issue.number }}
            });
            return pr.data.head.ref;

      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.get_branch.outputs.result }}

      - name: Install devctl from release binary
        run: |
          mkdir -p /tmp/devctl_install
          cd /tmp/devctl_install
          LATEST_DEVCTL_TAG=$(gh release view --repo giantswarm/devctl --json tagName --jq '.tagName')
          ASSET_NAME="devctl-${LATEST_DEVCTL_TAG}-linux-amd64.tar.gz"
          gh release download --repo giantswarm/devctl "$LATEST_DEVCTL_TAG" --pattern "$ASSET_NAME"
          tar -xzf "$ASSET_NAME"
          find . -name "devctl" -type f -exec sudo mv {} /usr/local/bin/devctl \;
          cd -
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Parse command arguments and determine provider
        id: parse_command
        run: |
          COMMENT_BODY="/update-release ${{ github.event.client_payload.slash_command.args }}"
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"

          # Extract devctl arguments, excluding the /update-release command and any --provider flag
          DEVCTL_ARGS=$(echo "$COMMENT_BODY" | sed -E 's|/update-release||; s/--provider[= ]+[a-zA-Z-]+//' | xargs)
          echo "devctl_args=$DEVCTL_ARGS" >> "$GITHUB_OUTPUT"

          # 1. Check for --provider in the comment
          COMMENT_PROVIDER=$(echo "$COMMENT_BODY" | grep -oP '(?<=--provider(=| ))[a-zA-Z-]+')

          # 2. If not in comment, try to get it from the branch name
          BRANCH_PROVIDER=$(echo "$BRANCH_NAME" | sed -n 's/release-v[0-9.]*-\(.*\)/\1/p')

          if [[ -n "$COMMENT_PROVIDER" ]]; then
            echo "Provider specified in comment: $COMMENT_PROVIDER"
            echo "provider=$COMMENT_PROVIDER" >> "$GITHUB_OUTPUT"
          elif [[ -n "$BRANCH_PROVIDER" ]]; then
            echo "Provider inferred from branch name: $BRANCH_PROVIDER"
            echo "provider=$BRANCH_PROVIDER" >> "$GITHUB_OUTPUT"
          else
            echo "provider_missing=true" >> "$GITHUB_OUTPUT"
            echo "Provider was not specified in the command and could not be inferred from branch name '$BRANCH_NAME'."
          fi

      - name: Add comment if provider is missing
        if: steps.parse_command.outputs.provider_missing == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.client_payload.issue.number }},
              body: "Could not determine the provider. For multi-provider releases, please specify the provider using the `--provider` flag. \n\n**Example:**\n`/update-release --provider aws --component flatcar@1.2.3`\n\nTo specify app dependencies, use the `#` separator:\n`/update-release --provider aws --app my-app@1.2.3@@dep1#dep2`"
            });
      - name: Fail job if provider is missing
        if: steps.parse_command.outputs.provider_missing == 'true'
        run: |
          exit 1

      - name: Recreate release files
        id: recreate_release
        if: steps.parse_command.outputs.provider_missing != 'true'
        run: |
          set -o pipefail
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDER="${{ steps.parse_command.outputs.provider }}"

          # 1. Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          if [[ -z "$RELEASE_NAME" ]]; then
            echo "Could not determine release name from branch '$BRANCH_NAME'. Aborting."
            exit 1
          fi

          # 2. Determine the correct previous release to use as a base.
          search_dir=$PROVIDER
          if [ "$PROVIDER" == "aws" ]; then
              search_dir="capa"
          fi
          BASE_VERSION=$(find "$search_dir" -name "v*" -type d -not -path "*/archived/*" -exec basename {} \; | grep -v "^${RELEASE_NAME}$" | sort -V | tail -n 1)
          if [[ -z "$BASE_VERSION" ]]; then
            echo "Error: Could not determine base version for release '$RELEASE_NAME'."
            exit 1
          fi
          echo "Updating release '$RELEASE_NAME' for provider '$PROVIDER' using base '$BASE_VERSION'"

          # 3. Recreate the release, applying user-provided changes on top of a fresh --bumpall.
          #    This ensures all components are at their latest correct versions, preventing reverts.
          devctl release create \
            --base "$BASE_VERSION" \
            --name "$RELEASE_NAME" \
            --provider "$PROVIDER" \
            --bumpall \
            ${{ steps.parse_command.outputs.devctl_args }} \
            --overwrite -y --output markdown --requested-only 2>&1 | tee /tmp/release_output.log

          LOG_CONTENT=$(cat /tmp/release_output.log)
          echo "LOG_CONTENT<<EOF" >> "$GITHUB_ENV"
          echo "${LOG_CONTENT}" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Commit and push changes
        if: steps.parse_command.outputs.provider_missing != 'true'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email '41898282+github-actions[bot]@users.noreply.github.com'
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: Update release files via comment"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Add success reaction
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.client_payload.comment.id }},
              content: '+1'
            })
      - name: Read log file to env
        run: |
          log_content=$(cat /tmp/release_output.log)
          echo "LOG_CONTENT<<EOF" >> $GITHUB_ENV
          echo "${log_content}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Post devctl output as a comment
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = process.env.LOG_CONTENT;
            const provider = "${{ steps.parse_command.outputs.provider }}";
            github.rest.issues.createComment({
              issue_number: ${{ github.event.client_payload.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `### Changes for ${provider.toUpperCase()}\n\n${output.replace(/`/g, '\\`')}`
            });
