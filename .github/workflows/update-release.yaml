name: Update Release PR (Comment Trigger)

on:
  issue_comment:
    types: [created]

jobs:
  update-release:
    # This job only runs for pull request comments
    if: github.event.issue.pull_request && startsWith(github.event.comment.body, '/update-release') && github.repository == 'giantswarm/releases' && github.event.sender.type != 'Bot' && github.event.sender.login != 'taylorbot'
    runs-on: ubuntu-latest
    env:
      OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Add reaction to comment to indicate that the bot is working on the update
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: 'eyes'
            })

      - name: Get PR branch name
        id: get_branch
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          result-encoding: string
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.issue.number }}
            });
            return pr.data.head.ref;

      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.get_branch.outputs.result }}

      - name: Install devctl from release binary
        run: |
          mkdir -p /tmp/devctl_install
          cd /tmp/devctl_install
          LATEST_DEVCTL_TAG=$(gh release view --repo giantswarm/devctl --json tagName --jq '.tagName')
          ASSET_NAME="devctl-${LATEST_DEVCTL_TAG}-linux-amd64.tar.gz"
          gh release download --repo giantswarm/devctl "$LATEST_DEVCTL_TAG" --pattern "$ASSET_NAME"
          tar -xzf "$ASSET_NAME"
          find . -name "devctl" -type f -exec sudo mv {} /usr/local/bin/devctl \;
          cd -
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Parse command arguments and determine provider(s)
        id: parse_command
        run: |
          COMMENT_BODY="${{ github.event.comment.body }}"

          # Extract devctl arguments, excluding the /update-release command and any --provider flag
          DEVCTL_ARGS=$(echo "$COMMENT_BODY" | sed -E 's|/update-release||; s/--provider[= ]+[a-zA-Z-]+//' | xargs)
          echo "devctl_args=$DEVCTL_ARGS" >> "$GITHUB_OUTPUT"

          # Check for --provider in the comment
          COMMENT_PROVIDER=$(echo "$COMMENT_BODY" | grep -oP '(?<=--provider(=| ))[a-zA-Z-]+' || true)

          if [[ -n "$COMMENT_PROVIDER" ]]; then
            echo "Provider specified in comment: $COMMENT_PROVIDER"
            echo "provider=$COMMENT_PROVIDER" >> "$GITHUB_OUTPUT"
          else
            echo "No provider specified. Detecting providers from PR files."
            # Get providers from the PR's changed files.
            PR_PROVIDERS=$(gh pr view ${{ github.event.issue.number }} --json files --jq '.files[].path' | cut -d'/' -f1 | sort -u | xargs)
            # List of valid provider directories.
            VALID_PROVIDERS="azure capa cloud-director vsphere"
            PROVIDERS_LIST=""
            for provider in $PR_PROVIDERS; do
              if [[ " $VALID_PROVIDERS " =~ " $provider " ]]; then
                PROVIDERS_LIST="$PROVIDERS_LIST $provider"
              fi
            done
            # Trim leading/trailing whitespace.
            PROVIDERS_LIST=$(echo "$PROVIDERS_LIST" | xargs)
            if [[ -z "$PROVIDERS_LIST" ]]; then
              echo "Could not determine any providers from the PR files."
            fi
            echo "Detected providers: $PROVIDERS_LIST"
            echo "providers_list=${PROVIDERS_LIST}" >> "$GITHUB_OUTPUT"
          fi

      - name: Recreate release files
        id: recreate_release
        if: success() && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          set -o pipefail
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDERS_TO_UPDATE="${{ steps.parse_command.outputs.provider }}${{ steps.parse_command.outputs.providers_list }}"
          
          # For `devctl`, the provider for the `capa` directory is `aws`.
          # We must translate `aws` to `capa` for directory lookups.
          if [[ " ${PROVIDERS_TO_UPDATE} " =~ " aws " ]]; then
            PROVIDERS_TO_UPDATE=$(echo "${PROVIDERS_TO_UPDATE}" | sed 's/aws/capa/g')
          fi

          # 1. Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          if [[ -z "$RELEASE_NAME" ]]; then
            echo "Could not determine release name from branch '$BRANCH_NAME'. Aborting."
            exit 1
          fi

          FULL_LOG_CONTENT=""

          for PROVIDER in $PROVIDERS_TO_UPDATE; do
            PROVIDER_DIR=$PROVIDER
            echo "Processing provider: $PROVIDER_DIR"

            # For `devctl`, the provider for the `capa` directory is `aws`.
            if [ "$PROVIDER" == "capa" ]; then
                PROVIDER="aws"
            fi

            # Check if release directory for the given release name exists for the provider in the current branch
            if [ ! -d "$PROVIDER_DIR/$RELEASE_NAME" ]; then
              echo "Release '$RELEASE_NAME' does not exist for provider '$PROVIDER_DIR' (in directory '$PROVIDER_DIR'). Skipping."
              continue
            fi

            echo "Updating release '$RELEASE_NAME' for provider '$PROVIDER_DIR'"

            # 3. Recreate the release
            DEVCTL_ARGS="${{ steps.parse_command.outputs.devctl_args }}"
            DEVCTL_COMMAND="devctl release create --name \"$RELEASE_NAME\" --provider \"$PROVIDER\" --overwrite -y --output markdown --requested-only --update-existing"

            # By default, we only bump all components if no specific app/component is requested.
            if [[ "$DEVCTL_ARGS" == *--app* || "$DEVCTL_ARGS" == *--component* ]]; then
              echo "Specific app/component version requested, not bumping all."
              DEVCTL_COMMAND="$DEVCTL_COMMAND $DEVCTL_ARGS"
            else
              echo "No specific app/component version requested, bumping all."
              DEVCTL_COMMAND="$DEVCTL_COMMAND --bumpall $DEVCTL_ARGS"
            fi

            echo "Running command: $DEVCTL_COMMAND"
            
            # Check for changes before running the command
            BEFORE_HASH=""
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
              BEFORE_HASH=$(sha256sum "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" | cut -d' ' -f1)
            fi
            
            if ! output=$(eval "$DEVCTL_COMMAND" 2>&1 | uniq); then
                LOG_PART="### User-requested changes for ${PROVIDER_DIR^^}\n\n"
                LOG_PART="${LOG_PART}devctl command failed for provider $PROVIDER_DIR.\n\n"
                LOG_PART="${LOG_PART}<details><summary>Error Log</summary>\n\n"
                LOG_PART="${LOG_PART}_Output of \`devctl release create\`_: \n"
                LOG_PART="${LOG_PART}\`\`\`\n${output}\n\`\`\`\n\n"
                LOG_PART="${LOG_PART}</details>\n\n"
                FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
            else
                LOG_PART="### User-requested changes for ${PROVIDER_DIR^^}\n\n"
                
                # Check if files actually changed
                AFTER_HASH=""
                if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
                  AFTER_HASH=$(sha256sum "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" | cut -d' ' -f1)
                fi
                
                # Determine if changes were made
                if [[ "$BEFORE_HASH" != "$AFTER_HASH" ]]; then
                  # Files changed, show what was requested
                  if [[ -z "$(echo -e "${output}" | tr -d '[:space:]')" ]]; then
                    # Generate a table showing what changed
                    CHANGES_TABLE=""
                    
                    # Parse the requested changes and show them in table format
                    if [[ "$DEVCTL_ARGS" == *--app* ]]; then
                      CHANGES_TABLE="${CHANGES_TABLE}| APP NAME | DESIRED APP VERSION |\n"
                      CHANGES_TABLE="${CHANGES_TABLE}|----------|--------------------|\n"
                      
                      # Extract app changes from the arguments
                      APP_SPECS=$(echo "$DEVCTL_ARGS" | grep -oE '\--app [^ ]+' | sed 's/--app //')
                      for app_spec in $APP_SPECS; do
                        if [[ "$app_spec" == *@* ]]; then
                          app_name=$(echo "$app_spec" | cut -d'@' -f1)
                          app_version=$(echo "$app_spec" | cut -d'@' -f2)
                          CHANGES_TABLE="${CHANGES_TABLE}| $app_name | **$app_version** |\n"
                        fi
                      done
                    fi
                    
                    if [[ "$DEVCTL_ARGS" == *--component* ]]; then
                      if [[ -n "$CHANGES_TABLE" ]]; then
                        CHANGES_TABLE="${CHANGES_TABLE}\n"
                      fi
                      CHANGES_TABLE="${CHANGES_TABLE}| COMPONENT NAME | DESIRED VERSION |\n"
                      CHANGES_TABLE="${CHANGES_TABLE}|----------------|----------------|\n"
                      
                      # Extract component changes from the arguments
                      COMP_SPECS=$(echo "$DEVCTL_ARGS" | grep -oE '\--component [^ ]+' | sed 's/--component //')
                      for comp_spec in $COMP_SPECS; do
                        if [[ "$comp_spec" == *@* ]]; then
                          comp_name=$(echo "$comp_spec" | cut -d'@' -f1)
                          comp_version=$(echo "$comp_spec" | cut -d'@' -f2)
                          CHANGES_TABLE="${CHANGES_TABLE}| $comp_name | **$comp_version** |\n"
                        fi
                      done
                    fi
                    
                    if [[ -n "$CHANGES_TABLE" ]]; then
                      LOG_PART="${LOG_PART}${CHANGES_TABLE}\n"
                    else
                      LOG_PART="${LOG_PART}✅ Changes applied successfully.\n\n"
                    fi
                  else
                    LOG_PART="${LOG_PART}${output}\n\n"
                  fi
                else
                  # No changes detected
                  LOG_PART="${LOG_PART}No changes detected for provider ${PROVIDER_DIR^^}. The requested app/component versions may already be present in the current release.\n\n"
                fi
                FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
            fi
          done

          # Replace literal '\n' with actual newlines for proper rendering in the GitHub comment.
          FULL_LOG_CONTENT=$(printf '%b' "${FULL_LOG_CONTENT}")

          # Use GITHUB_ENV to avoid issues with special characters in output strings.
          echo "DEVCTL_OUTPUT_COMMENT<<EOF" >> "$GITHUB_ENV"
          echo "$FULL_LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Commit and push changes
        if: success() && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email '41898282+github-actions[bot]@users.noreply.github.com'
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: Update release files via comment"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Add success reaction
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: '+1'
            })
      - name: Post devctl output as a comment
        if: env.DEVCTL_OUTPUT_COMMENT != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = process.env.DEVCTL_OUTPUT_COMMENT;
            github.rest.issues.createComment({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });
