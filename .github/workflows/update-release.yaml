name: Update Release PR (Comment Trigger)

on:
  issue_comment:
    types: [created]

jobs:
  update-release:
    # This job only runs for pull request comments
    if: github.event.issue.pull_request && (startsWith(github.event.comment.body, '/update-release') || startsWith(github.event.comment.body, '/update-readme') || startsWith(github.event.comment.body, '/update-announcement')) && github.repository == 'giantswarm/releases'
    runs-on: ubuntu-latest
    env:
      OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Add reaction to comment to indicate that the bot is working on the update
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: 'eyes'
            })

      - name: Get PR branch name
        id: get_branch
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          result-encoding: string
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.issue.number }}
            });
            return pr.data.head.ref;

      - name: Detect if automatic bump or manual update
        id: detect_source
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const commentAuthor = context.payload.comment.user.login;
            const botUsers = ['taylorbot', 'github-actions[bot]'];
            const isAutomatic = botUsers.includes(commentAuthor);
            
            core.setOutput('is_automatic', isAutomatic.toString());
            core.setOutput('source_type', isAutomatic ? 'automatic' : 'manual');
            
            console.log(`Comment author: ${commentAuthor}`);
            console.log(`Is automatic: ${isAutomatic}`);

      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.get_branch.outputs.result }}

      - name: Install devctl from release binary
        run: |
          mkdir -p /tmp/devctl_install
          cd /tmp/devctl_install
          LATEST_DEVCTL_TAG=$(gh release view --repo giantswarm/devctl --json tagName --jq '.tagName')
          ASSET_NAME="devctl-${LATEST_DEVCTL_TAG}-linux-amd64.tar.gz"
          gh release download --repo giantswarm/devctl "$LATEST_DEVCTL_TAG" --pattern "$ASSET_NAME"
          tar -xzf "$ASSET_NAME"
          find . -name "devctl" -type f -exec sudo mv {} /usr/local/bin/devctl \;
          cd -
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Parse command arguments and determine provider(s)
        id: parse_command
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          # Use printf to safely handle quotes and special characters
          printf '%s\n' "$COMMENT_BODY" > /tmp/comment_body.txt

          # Check if this is a description-only update
          COMMENT_CONTENT=$(cat /tmp/comment_body.txt)
          if [[ "$COMMENT_CONTENT" == *"/update-readme"* ]]; then
            echo "description_only=true" >> "$GITHUB_OUTPUT"
            echo "update_type=readme" >> "$GITHUB_OUTPUT"
            # Extract description safely from file
            if [[ "$COMMENT_CONTENT" == *"--provider"* ]]; then
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|.*--provider[= ]+[a-zA-Z-]+ +||' | sed 's/^"//' | sed 's/"$//')
            else
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|/update-readme +||' | sed 's/^"//' | sed 's/"$//')
            fi
            # Use base64 encoding to safely pass description with special characters
            echo "description=$(echo "$DESCRIPTION" | base64 -w 0)" >> "$GITHUB_OUTPUT"
            DEVCTL_ARGS=""
          elif [[ "$COMMENT_CONTENT" == *"/update-announcement"* ]]; then
            echo "description_only=true" >> "$GITHUB_OUTPUT"
            echo "update_type=announcement" >> "$GITHUB_OUTPUT"
            # Extract description safely from file
            if [[ "$COMMENT_CONTENT" == *"--provider"* ]]; then
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|.*--provider[= ]+[a-zA-Z-]+ +||' | sed 's/^"//' | sed 's/"$//')
            else
              DESCRIPTION=$(echo "$COMMENT_CONTENT" | sed -E 's|/update-announcement +||' | sed 's/^"//' | sed 's/"$//')
            fi
            # Use base64 encoding to safely pass description with special characters
            echo "description=$(echo "$DESCRIPTION" | base64 -w 0)" >> "$GITHUB_OUTPUT"
            DEVCTL_ARGS=""
          else
            echo "description_only=false" >> "$GITHUB_OUTPUT"
            # Extract devctl arguments, excluding the /update-release command and any --provider flag
            DEVCTL_ARGS=$(echo "$COMMENT_CONTENT" | sed -E 's|/update-release||; s/--provider[= ]+[a-zA-Z-]+//' | xargs)
          fi
          echo "devctl_args=$DEVCTL_ARGS" >> "$GITHUB_OUTPUT"

          # Check for --provider in the comment
          COMMENT_PROVIDER=$(echo "$COMMENT_BODY" | grep -oP '(?<=--provider(=| ))[a-zA-Z-]+' || true)

          if [[ -n "$COMMENT_PROVIDER" ]]; then
            echo "Provider specified in comment: $COMMENT_PROVIDER"
            echo "provider=$COMMENT_PROVIDER" >> "$GITHUB_OUTPUT"
          else
            echo "No provider specified. Detecting providers from PR files."
            # Get providers from the PR's changed files.
            PR_PROVIDERS=$(gh pr view ${{ github.event.issue.number }} --json files --jq '.files[].path' | cut -d'/' -f1 | sort -u | xargs)
            # List of valid provider directories.
            VALID_PROVIDERS="azure capa cloud-director eks vsphere"
            PROVIDERS_LIST=""
            for provider in $PR_PROVIDERS; do
              if [[ " $VALID_PROVIDERS " =~ " $provider " ]]; then
                PROVIDERS_LIST="$PROVIDERS_LIST $provider"
              fi
            done
            # Trim leading/trailing whitespace.
            PROVIDERS_LIST=$(echo "$PROVIDERS_LIST" | xargs)
            if [[ -z "$PROVIDERS_LIST" ]]; then
              echo "Could not determine any providers from the PR files."
            fi
            echo "Detected providers: $PROVIDERS_LIST"
            echo "providers_list=${PROVIDERS_LIST}" >> "$GITHUB_OUTPUT"
          fi

      - name: Update documentation
        id: update_docs
        if: success() && steps.parse_command.outputs.description_only == 'true' && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDERS_TO_UPDATE="${{ steps.parse_command.outputs.provider }}${{ steps.parse_command.outputs.providers_list }}"
          DESCRIPTION_B64="${{ steps.parse_command.outputs.description }}"
          UPDATE_TYPE="${{ steps.parse_command.outputs.update_type }}"

          # Decode description from base64
          DESCRIPTION=$(echo "$DESCRIPTION_B64" | base64 -d)

          # For `devctl`, the provider for the `capa` directory is `aws`.
          if [[ " ${PROVIDERS_TO_UPDATE} " =~ " aws " ]]; then
            PROVIDERS_TO_UPDATE=$(echo "${PROVIDERS_TO_UPDATE}" | sed 's/aws/capa/g')
          fi

          # Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          if [[ -z "$RELEASE_NAME" ]]; then
            echo "Could not determine release name from branch '$BRANCH_NAME'. Aborting."
            exit 1
          fi

          FULL_LOG_CONTENT=""

          for PROVIDER in $PROVIDERS_TO_UPDATE; do
            PROVIDER_DIR=$PROVIDER
            echo "Updating $UPDATE_TYPE for provider: $PROVIDER_DIR"

            # Check if release directory exists
            if [ ! -d "$PROVIDER_DIR/$RELEASE_NAME" ]; then
              echo "Release '$RELEASE_NAME' does not exist for provider '$PROVIDER_DIR'. Skipping."
              continue
            fi

            if [[ "$UPDATE_TYPE" == "readme" ]]; then
              # Update README.md
              README_FILE="$PROVIDER_DIR/$RELEASE_NAME/README.md"
              if [ -f "$README_FILE" ]; then
                # Backup the entire README.md content before making changes
                README_BACKUP=$(cat "$README_FILE")

                if grep -q "<< Add description here >>" "$README_FILE"; then
                  # Replace placeholder
                  sed -i "s/<< Add description here >>/$DESCRIPTION/g" "$README_FILE"
                  echo "Added description to README.md"
                else
                  # Replace the warning/description section (line 3, after title and blank line)
                  sed -i "3c\\$DESCRIPTION" "$README_FILE"
                  echo "Updated existing description in README.md"
                fi

                # Verify the change was made correctly and restore if needed
                if ! grep -q "$DESCRIPTION" "$README_FILE"; then
                  echo "Description update failed, restoring original content"
                  echo "$README_BACKUP" > "$README_FILE"
                fi
              fi
              # README updates are usually short, keep them expanded
              LOG_PART="### README updated for ${PROVIDER_DIR^^}\n\n"
              LOG_PART="${LOG_PART}üìù **README Description**: $DESCRIPTION\n\n"

            elif [[ "$UPDATE_TYPE" == "announcement" ]]; then
              # Update announcement.md
              ANNOUNCEMENT_FILE="$PROVIDER_DIR/$RELEASE_NAME/announcement.md"
              if [ -f "$ANNOUNCEMENT_FILE" ]; then
                # Determine provider name
                PROVIDER_NAME=""
                if [[ "$PROVIDER_DIR" == "capa" ]]; then
                  PROVIDER_NAME="CAPA"
                elif [[ "$PROVIDER_DIR" == "azure" ]]; then
                  PROVIDER_NAME="Azure"
                elif [[ "$PROVIDER_DIR" == "vsphere" ]]; then
                  PROVIDER_NAME="vSphere"
                elif [[ "$PROVIDER_DIR" == "cloud-director" ]]; then
                  PROVIDER_NAME="VMware Cloud Director"
                elif [[ "$PROVIDER_DIR" == "eks" ]]; then
                  PROVIDER_NAME="EKS"
                else
                  PROVIDER_NAME=$(echo "$PROVIDER_DIR" | tr 'a-z' 'A-Z')
                fi

                # Always recreate line 1 with the proper format
                RELEASE_VERSION=$(echo "$RELEASE_NAME" | sed 's/v//')
                NEW_LINE_1="**Workload cluster release v${RELEASE_VERSION} for ${PROVIDER_NAME} is available**. $DESCRIPTION"

                # Replace line 1 completely
                sed -i "1c\\$NEW_LINE_1" "$ANNOUNCEMENT_FILE"
                echo "Updated announcement.md with new description"
              fi
              # Announcement updates are usually short, keep them expanded
              LOG_PART="### Announcement updated for ${PROVIDER_DIR^^}\n\n"
              LOG_PART="${LOG_PART}üì¢ **Announcement**: $DESCRIPTION\n\n"
            fi

            FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
          done

          # Replace literal '\n' with actual newlines for proper rendering in the GitHub comment.
          FULL_LOG_CONTENT=$(printf '%b' "${FULL_LOG_CONTENT}")
          echo "DEVCTL_OUTPUT_COMMENT<<EOF" >> "$GITHUB_ENV"
          echo "$FULL_LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Recreate release files
        id: recreate_release
        if: success() && steps.parse_command.outputs.description_only != 'true' && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          set -o pipefail
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDERS_TO_UPDATE="${{ steps.parse_command.outputs.provider }}${{ steps.parse_command.outputs.providers_list }}"
          IS_AUTOMATIC="${{ steps.detect_source.outputs.is_automatic }}"

          # Determine the message prefix based on source
          if [[ "$IS_AUTOMATIC" == "true" ]]; then
            CHANGE_PREFIX="Weekly automatic bump"
          else
            CHANGE_PREFIX="User-requested changes"
          fi

          # For `devctl`, the provider for the `capa` directory is `aws`.
          # We must translate `aws` to `capa` for directory lookups.
          if [[ " ${PROVIDERS_TO_UPDATE} " =~ " aws " ]]; then
            PROVIDERS_TO_UPDATE=$(echo "${PROVIDERS_TO_UPDATE}" | sed 's/aws/capa/g')
          fi

          # 1. Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          if [[ -z "$RELEASE_NAME" ]]; then
            echo "Could not determine release name from branch '$BRANCH_NAME'. Aborting."
            exit 1
          fi

          FULL_LOG_CONTENT=""
          PROVIDERS_WITH_NO_CHANGES=""
          PROVIDERS_WITH_CHANGES=""

          for PROVIDER in $PROVIDERS_TO_UPDATE; do
            PROVIDER_DIR=$PROVIDER
            echo "Processing provider: $PROVIDER_DIR"

            # For `devctl`, the provider for the `capa` directory is `aws`.
            if [ "$PROVIDER" == "capa" ]; then
                PROVIDER="aws"
            fi

            # Check if release directory for the given release name exists for the provider in the current branch
            if [ ! -d "$PROVIDER_DIR/$RELEASE_NAME" ]; then
              echo "Release '$RELEASE_NAME' does not exist for provider '$PROVIDER_DIR' (in directory '$PROVIDER_DIR'). Skipping."
              continue
            fi

            echo "Updating release '$RELEASE_NAME' for provider '$PROVIDER_DIR'"

            # 3. Read current release versions to preserve pinned components/apps
            CURRENT_RELEASE_FILE="${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml"
            REQUESTS_FILE="${PROVIDER_DIR}/requests.yaml"
            PIN_ARGS=""
            
            if [ -f "$CURRENT_RELEASE_FILE" ] && [ -f "$REQUESTS_FILE" ]; then
              echo "Checking for pinned versions in current release $RELEASE_NAME"
              
              # Find which items are pinned in requests.yaml (to know what to preserve)
              PINNED_NAMES=$(yq eval '.releases[] | select(
                .name == "'"$RELEASE_NAME"'" or
                .name == "v'"${RELEASE_NAME#v}"'" or
                ((.name | test("^>= .* < .*$")) and ("'"$RELEASE_NAME"'" | test(.name)))
              ) | .requests[]? | .name' "$REQUESTS_FILE" 2>/dev/null || true)
              
              if [ -n "$PINNED_NAMES" ]; then
                echo "Found pinned items in requests.yaml:"
                echo "$PINNED_NAMES"
                
                # For each pinned item, get its CURRENT version from the release (not from requests.yaml)
                while IFS= read -r NAME; do
                  if [ -n "$NAME" ]; then
                    # Try to find in components first
                    CURRENT_VERSION=$(yq eval '.spec.components[] | select(.name == "'"$NAME"'") | .version' "$CURRENT_RELEASE_FILE" 2>/dev/null || true)
                    
                    if [ -n "$CURRENT_VERSION" ]; then
                      PIN_ARGS="$PIN_ARGS --component $NAME@$CURRENT_VERSION"
                      echo "  üìå Preserving pinned component: $NAME@$CURRENT_VERSION"
                    else
                      # Try to find in apps
                      CURRENT_VERSION=$(yq eval '.spec.apps[] | select(.name == "'"$NAME"'") | .version' "$CURRENT_RELEASE_FILE" 2>/dev/null || true)
                      
                      if [ -n "$CURRENT_VERSION" ]; then
                        PIN_ARGS="$PIN_ARGS --app $NAME@$CURRENT_VERSION"
                        echo "  üìå Preserving pinned app: $NAME@$CURRENT_VERSION"
                      fi
                    fi
                  fi
                done <<< "$PINNED_NAMES"
              else
                echo "No pinned versions found in requests.yaml for this release"
              fi
            fi

            # 4. Recreate the release
            DEVCTL_ARGS="${{ steps.parse_command.outputs.devctl_args }}"

            # By default, we bump all apps/components to latest versions if no specific version is requested.
            if [[ "$DEVCTL_ARGS" == *--app* || "$DEVCTL_ARGS" == *--component* ]]; then
              echo "Specific app/component version requested, using --update-existing with --regenerate-readme."
              DEVCTL_COMMAND="devctl release create --name \"$RELEASE_NAME\" --provider \"$PROVIDER\" --overwrite -y --output markdown --requested-only --update-existing --regenerate-readme $DEVCTL_ARGS $PIN_ARGS"
            else
              echo "No specific app/component version requested, bumping all to latest versions."
              # Determine the base release for --bumpall
              # The release type parameter is required by the script but ignored when version override is provided
              # The script intelligently determines the base from the version itself (major/minor/patch)
              BASE_VERSION=$(./tools/determine-next-release.sh "$PROVIDER" "patch" "$RELEASE_NAME" | grep '^base=' | cut -d'=' -f2)
              echo "Determined base version: $BASE_VERSION"
              # When using --bumpall, add pinned versions as explicit constraints
              DEVCTL_COMMAND="devctl release create --name \"$RELEASE_NAME\" --provider \"$PROVIDER\" --base \"$BASE_VERSION\" --overwrite -y --output markdown --bumpall $DEVCTL_ARGS $PIN_ARGS"
            fi

            echo "Running command: $DEVCTL_COMMAND"

            # Check for changes before running the command
            BEFORE_HASH=""
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
              BEFORE_HASH=$(sha256sum "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" | cut -d' ' -f1)
            fi

            # Backup all files before devctl modifies them (to restore if no actual changes)
            RELEASE_YAML_BACKUP=""
            RELEASE_DIFF_BACKUP=""
            RELEASES_JSON_BACKUP=""
            
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
              RELEASE_YAML_BACKUP=$(cat "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml")
            fi
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.diff" ]; then
              RELEASE_DIFF_BACKUP=$(cat "${PROVIDER_DIR}/${RELEASE_NAME}/release.diff")
            fi
            if [ -f "${PROVIDER_DIR}/releases.json" ]; then
              RELEASES_JSON_BACKUP=$(cat "${PROVIDER_DIR}/releases.json")
            fi

            # Backup existing descriptions before devctl overwrites them
            README_DESCRIPTION_BACKUP=""
            ANNOUNCEMENT_BACKUP=""
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/README.md" ] && ! grep -q "<< Add description here >>" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"; then
              # Extract existing README description (line 3, which is the warning/description)
              README_DESCRIPTION_BACKUP=$(sed -n '3p' "${PROVIDER_DIR}/${RELEASE_NAME}/README.md" || true)
            fi
            if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md" ] && ! grep -q "<< Add description here >>" "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md"; then
              # Extract existing announcement description (everything after "**. ")
              ANNOUNCEMENT_BACKUP=$(sed -n '1p' "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md" | sed 's/.*\*\*\. //' || true)
            fi

            if ! output=$(eval "$DEVCTL_COMMAND" 2>&1 | uniq); then
                # Error case - always collapse
                LOG_PART="<details><summary>${CHANGE_PREFIX} for ${PROVIDER_DIR^^}</summary>\n\n"
                LOG_PART="${LOG_PART}devctl command failed for provider $PROVIDER_DIR.\n\n"
                LOG_PART="${LOG_PART}<details><summary>Error Log</summary>\n\n"
                LOG_PART="${LOG_PART}_Output of \`devctl release create\`_: \n"
                LOG_PART="${LOG_PART}\`\`\`\n${output}\n\`\`\`\n\n"
                LOG_PART="${LOG_PART}</details>\n\n"
                LOG_PART="${LOG_PART}</details>\n\n"
                FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
            else
                # Check if files actually changed
                AFTER_HASH=""
                if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
                  AFTER_HASH=$(sha256sum "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" | cut -d' ' -f1)
                fi

                # Build the content first (without details wrapper)
                CONTENT_PART=""

                # Determine if changes were made
                # Check if output contains only "Unchanged" entries (devctl regenerated files but no version changes)
                ACTUAL_CHANGES_EXIST=true
                if [[ -n "$output" ]]; then
                  # Count lines with actual version changes (bold text **version** indicates change)
                  CHANGED_COUNT=$(echo -e "$output" | grep -c '\*\*' || echo "0")
                  # Count lines that say "Unchanged"
                  UNCHANGED_COUNT=$(echo -e "$output" | grep -c 'Unchanged' || echo "0")
                  
                  echo "  Change detection: CHANGED_COUNT=$CHANGED_COUNT, UNCHANGED_COUNT=$UNCHANGED_COUNT"
                  
                  # If we have Unchanged entries but no actual changes (no bold text), treat as no changes
                  if [[ $UNCHANGED_COUNT -gt 0 && $CHANGED_COUNT -eq 0 ]]; then
                    ACTUAL_CHANGES_EXIST=false
                    echo "  Detection: File hash changed but all items show 'Unchanged' - treating as no changes"
                    echo "  Restoring original files to prevent timestamp-only commits"
                    
                    # Restore original files to prevent timestamp-only changes from being committed
                    if [[ -n "$RELEASE_YAML_BACKUP" ]]; then
                      echo "$RELEASE_YAML_BACKUP" > "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml"
                    fi
                    if [[ -n "$RELEASE_DIFF_BACKUP" ]]; then
                      echo "$RELEASE_DIFF_BACKUP" > "${PROVIDER_DIR}/${RELEASE_NAME}/release.diff"
                    fi
                    if [[ -n "$RELEASES_JSON_BACKUP" ]]; then
                      echo "$RELEASES_JSON_BACKUP" > "${PROVIDER_DIR}/releases.json"
                    fi
                    
                    # Recompute hash after restoration
                    if [ -f "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" ]; then
                      AFTER_HASH=$(sha256sum "${PROVIDER_DIR}/${RELEASE_NAME}/release.yaml" | cut -d' ' -f1)
                    fi
                  fi
                fi

                # Only show changes if hash changed AND actual version changes exist
                if [[ "$BEFORE_HASH" != "$AFTER_HASH" ]] && [[ "$ACTUAL_CHANGES_EXIST" == "true" ]]; then
                  # Files changed AND actual version changes detected
                  if [[ -z "$(echo -e "${output}" | tr -d '[:space:]')" ]]; then
                    # Generate a table showing what changed
                    CHANGES_TABLE=""

                    # Parse the requested changes and show them in table format
                    if [[ "$DEVCTL_ARGS" == *--app* ]]; then
                      CHANGES_TABLE="${CHANGES_TABLE}| APP NAME | CURRENT APP VERSION | DESIRED APP VERSION |\n"
                      CHANGES_TABLE="${CHANGES_TABLE}|----------|---------------------|---------------------|\n"

                      # Extract app changes from the arguments
                      APP_SPECS=$(echo "$DEVCTL_ARGS" | grep -oE '\--app [^ ]+' | sed 's/--app //')
                      for app_spec in $APP_SPECS; do
                        if [[ "$app_spec" == *@* ]]; then
                          app_name=$(echo "$app_spec" | cut -d'@' -f1)
                          app_version=$(echo "$app_spec" | cut -d'@' -f2)

                          # Try to find the current version from the release.yaml backup (before the update)
                          CURRENT_VERSION=""
                          if [[ -n "$RELEASE_YAML_BACKUP" ]]; then
                            # Look for the app in the release.yaml backup and extract its current version
                            CURRENT_VERSION=$(echo "$RELEASE_YAML_BACKUP" | awk -v app="$app_name" '
                              /^  - name:/ { current_app = $3 }
                              current_app == app && /^    version:/ { print $2; exit }
                            ')
                          fi

                          if [[ -n "$CURRENT_VERSION" ]]; then
                            CHANGES_TABLE="${CHANGES_TABLE}| $app_name | $CURRENT_VERSION | **$app_version** |\n"
                          else
                            CHANGES_TABLE="${CHANGES_TABLE}| $app_name | _(new)_ | **$app_version** |\n"
                          fi
                        fi
                      done
                    fi

                    if [[ "$DEVCTL_ARGS" == *--component* ]]; then
                      if [[ -n "$CHANGES_TABLE" ]]; then
                        CHANGES_TABLE="${CHANGES_TABLE}\n"
                      fi
                      CHANGES_TABLE="${CHANGES_TABLE}| COMPONENT NAME | CURRENT VERSION | DESIRED VERSION |\n"
                      CHANGES_TABLE="${CHANGES_TABLE}|----------------|-----------------|----------------|\n"

                      # Extract component changes from the arguments
                      COMP_SPECS=$(echo "$DEVCTL_ARGS" | grep -oE '\--component [^ ]+' | sed 's/--component //')
                      for comp_spec in $COMP_SPECS; do
                        if [[ "$comp_spec" == *@* ]]; then
                          comp_name=$(echo "$comp_spec" | cut -d'@' -f1)
                          comp_version=$(echo "$comp_spec" | cut -d'@' -f2)

                          # Try to find the current version from the release.yaml backup (before the update)
                          CURRENT_COMP_VERSION=""
                          if [[ -n "$RELEASE_YAML_BACKUP" ]]; then
                            # Look for the component in the release.yaml backup and extract its current version
                            CURRENT_COMP_VERSION=$(echo "$RELEASE_YAML_BACKUP" | awk -v comp="$comp_name" '
                              /^  - name:/ { current_comp = $3 }
                              current_comp == comp && /^    version:/ { print $2; exit }
                            ')
                          fi

                          if [[ -n "$CURRENT_COMP_VERSION" ]]; then
                            CHANGES_TABLE="${CHANGES_TABLE}| $comp_name | $CURRENT_COMP_VERSION | **$comp_version** |\n"
                          else
                            CHANGES_TABLE="${CHANGES_TABLE}| $comp_name | _(new)_ | **$comp_version** |\n"
                          fi
                        fi
                      done
                    fi

                    if [[ -n "$CHANGES_TABLE" ]]; then
                      CONTENT_PART="${CONTENT_PART}${CHANGES_TABLE}\n"
                    else
                      CONTENT_PART="${CONTENT_PART}‚úÖ Changes applied successfully.\n\n"
                    fi
                  else
                    CONTENT_PART="${CONTENT_PART}${output}\n\n"
                  fi
                else
                  # No changes detected (either hash unchanged OR all items show 'Unchanged')
                  CONTENT_PART="${CONTENT_PART}No changes detected for provider ${PROVIDER_DIR^^}. All components and apps are already at the requested versions.\n\n"
                fi

                # Check if this is a "no changes" message
                if [[ "$CONTENT_PART" == *"No changes detected"* ]]; then
                  # Track provider with no changes (for summary at the end)
                  if [[ -z "$PROVIDERS_WITH_NO_CHANGES" ]]; then
                    PROVIDERS_WITH_NO_CHANGES="$PROVIDER_DIR"
                  else
                    PROVIDERS_WITH_NO_CHANGES="$PROVIDERS_WITH_NO_CHANGES $PROVIDER_DIR"
                  fi
                else
                  # Track provider with changes
                  if [[ -z "$PROVIDERS_WITH_CHANGES" ]]; then
                    PROVIDERS_WITH_CHANGES="$PROVIDER_DIR"
                  else
                    PROVIDERS_WITH_CHANGES="$PROVIDERS_WITH_CHANGES $PROVIDER_DIR"
                  fi
                  
                  # Count the number of lines in the output to determine if we should collapse it
                  # Count lines that look like table rows (contain |) as a proxy for number of changes
                  CHANGE_COUNT=$(echo -e "$output" | grep -c '|' || echo "0")

                  # Only wrap in details if there are more than 5 changes (roughly 5 table rows)
                  if [[ $CHANGE_COUNT -gt 5 ]]; then
                    LOG_PART="<details><summary>${CHANGE_PREFIX} for ${PROVIDER_DIR^^}</summary>\n\n"
                    LOG_PART="${LOG_PART}${CONTENT_PART}"
                    LOG_PART="${LOG_PART}</details>\n\n"
                  else
                    LOG_PART="### ${CHANGE_PREFIX} for ${PROVIDER_DIR^^}\n\n"
                    LOG_PART="${LOG_PART}${CONTENT_PART}"
                  fi

                  FULL_LOG_CONTENT="${FULL_LOG_CONTENT}${LOG_PART}"
                fi
            fi

            # Restore README description if it existed before devctl overwrote it
            if [[ -n "$README_DESCRIPTION_BACKUP" ]]; then
              sed -i "3c\\$README_DESCRIPTION_BACKUP" "${PROVIDER_DIR}/${RELEASE_NAME}/README.md"
              echo "Restored description in README.md"
            fi
            if [[ -n "$ANNOUNCEMENT_BACKUP" ]]; then
              # Determine provider name for restore
              PROVIDER_NAME=""
              if [[ "$PROVIDER_DIR" == "capa" ]]; then
                PROVIDER_NAME="CAPA"
              elif [[ "$PROVIDER_DIR" == "azure" ]]; then
                PROVIDER_NAME="Azure"
              elif [[ "$PROVIDER_DIR" == "vsphere" ]]; then
                PROVIDER_NAME="vSphere"
              elif [[ "$PROVIDER_DIR" == "cloud-director" ]]; then
                PROVIDER_NAME="VMware Cloud Director"
              elif [[ "$PROVIDER_DIR" == "eks" ]]; then
                PROVIDER_NAME="EKS"
              else
                PROVIDER_NAME=$(echo "$PROVIDER_DIR" | tr 'a-z' 'A-Z')
              fi

              # Recreate line 1 with proper format when restoring
              RELEASE_VERSION=$(echo "$RELEASE_NAME" | sed 's/v//')
              NEW_LINE_1="**Workload cluster release v${RELEASE_VERSION} for ${PROVIDER_NAME} is available**. $ANNOUNCEMENT_BACKUP"
              sed -i "1c\\$NEW_LINE_1" "${PROVIDER_DIR}/${RELEASE_NAME}/announcement.md"
              echo "Restored description in announcement.md"
            fi
          done

          # After loop: Check if all providers had no changes
          if [[ -n "$PROVIDERS_WITH_NO_CHANGES" && -z "$PROVIDERS_WITH_CHANGES" ]]; then
            # All providers had no changes - show single summary message
            PROVIDER_COUNT=$(echo "$PROVIDERS_WITH_NO_CHANGES" | wc -w | xargs)
            if [[ $PROVIDER_COUNT -eq 1 ]]; then
              FULL_LOG_CONTENT="No changes detected for provider ${PROVIDERS_WITH_NO_CHANGES^^}. All components and apps are already at the requested versions.\n\n"
            else
              # Multiple providers, all with no changes
              PROVIDER_LIST=$(echo "$PROVIDERS_WITH_NO_CHANGES" | tr ' ' '\n' | tr '[:lower:]' '[:upper:]' | paste -sd ", " -)
              FULL_LOG_CONTENT="No changes detected in any provider ($PROVIDER_LIST). All components and apps are already at the requested versions.\n\n"
            fi
          fi

          # Replace literal '\n' with actual newlines for proper rendering in the GitHub comment.
          FULL_LOG_CONTENT=$(printf '%b' "${FULL_LOG_CONTENT}")

          # Use GITHUB_ENV to avoid issues with special characters in output strings.
          echo "DEVCTL_OUTPUT_COMMENT<<EOF" >> "$GITHUB_ENV"
          echo "$FULL_LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Check Upgrade Path
        if: success() && steps.parse_command.outputs.description_only != 'true' && steps.parse_command.outputs.devctl_args == ''
        run: |
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDERS_TO_UPDATE="${{ steps.parse_command.outputs.provider }}${{ steps.parse_command.outputs.providers_list }}"

          # Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')

          # Collect valid providers (those that have the release directory)
          VALID_PROVIDERS=""
          for PROVIDER_DIR in $PROVIDERS_TO_UPDATE; do
            # Translate capa -> aws for directory lookup
            CHECK_DIR=$PROVIDER_DIR
            if [[ "$PROVIDER_DIR" == "aws" ]]; then
              CHECK_DIR="capa"
            fi

            echo "Checking if release exists for provider: $CHECK_DIR, version: $RELEASE_NAME"

            # Check if release directory exists
            if [ ! -d "$CHECK_DIR/$RELEASE_NAME" ]; then
              echo "Release '$RELEASE_NAME' does not exist for provider '$CHECK_DIR'. Skipping."
              continue
            fi

            # Add to valid providers list (use original provider name, not directory name)
            if [ -z "$VALID_PROVIDERS" ]; then
              VALID_PROVIDERS="$PROVIDER_DIR"
            else
              VALID_PROVIDERS="$VALID_PROVIDERS,$PROVIDER_DIR"
            fi
          done

          # Run the upgrade path checker for all valid providers at once
          if [ -n "$VALID_PROVIDERS" ]; then
            echo "Checking upgrade path for providers: $VALID_PROVIDERS, version: $RELEASE_NAME"
            cd tools/check-upgrade-path
            go run . --providers "$VALID_PROVIDERS" --version "$RELEASE_NAME" --workdir ../.. --output "upgrade-path-warning.md" || true
            cd ../..
          else
            echo "No valid providers found for upgrade path check."
          fi

      - name: Post Upgrade Path Warning
        if: success() && steps.parse_command.outputs.description_only != 'true' && steps.parse_command.outputs.devctl_args == ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const fs = require('fs');

            // Check for consolidated warning file
            const warningFile = 'upgrade-path-warning.md';
            if (fs.existsSync(warningFile)) {
              const content = fs.readFileSync(warningFile, 'utf8');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ github.event.issue.number }},
                body: content
              });
            }

      - name: Commit and push changes
        if: success() && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email '41898282+github-actions[bot]@users.noreply.github.com'
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: Update release files via comment"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Add success reaction
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: '+1'
            })
      - name: Post devctl output as a comment
        if: env.DEVCTL_OUTPUT_COMMENT != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = process.env.DEVCTL_OUTPUT_COMMENT;
            github.rest.issues.createComment({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });
