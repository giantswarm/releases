name: Update Release PR (Comment Trigger)

on:
  issue_comment:
    types: [created]

jobs:
  update-release:
    # This job only runs for pull request comments
    if: github.event.issue.pull_request && startsWith(github.event.comment.body, '/update-release') && github.repository == 'giantswarm/releases' && github.event.sender.type != 'Bot' && github.event.sender.login != 'taylorbot'
    runs-on: ubuntu-latest
    env:
      OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Add reaction to comment to indicate that the bot is working on the update
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: 'eyes'
            })

      - name: Get PR branch name
        id: get_branch
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          result-encoding: string
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ github.event.issue.number }}
            });
            return pr.data.head.ref;

      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.get_branch.outputs.result }}

      - name: Install devctl from release binary
        run: |
          mkdir -p /tmp/devctl_install
          cd /tmp/devctl_install
          LATEST_DEVCTL_TAG=$(gh release view --repo giantswarm/devctl --json tagName --jq '.tagName')
          ASSET_NAME="devctl-${LATEST_DEVCTL_TAG}-linux-amd64.tar.gz"
          gh release download --repo giantswarm/devctl "$LATEST_DEVCTL_TAG" --pattern "$ASSET_NAME"
          tar -xzf "$ASSET_NAME"
          find . -name "devctl" -type f -exec sudo mv {} /usr/local/bin/devctl \;
          cd -
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Parse command arguments and determine provider(s)
        id: parse_command
        run: |
          COMMENT_BODY="${{ github.event.comment.body }}"

          # Extract devctl arguments, excluding the /update-release command and any --provider flag
          DEVCTL_ARGS=$(echo "$COMMENT_BODY" | sed -E 's|/update-release||; s/--provider[= ]+[a-zA-Z-]+//' | xargs)
          echo "devctl_args=$DEVCTL_ARGS" >> "$GITHUB_OUTPUT"

          # Check for --provider in the comment
          COMMENT_PROVIDER=$(echo "$COMMENT_BODY" | grep -oP '(?<=--provider(=| ))[a-zA-Z-]+')

          if [[ -n "$COMMENT_PROVIDER" ]]; then
            echo "Provider specified in comment: $COMMENT_PROVIDER"
            echo "provider=$COMMENT_PROVIDER" >> "$GITHUB_OUTPUT"
          else
            echo "No provider specified. Will attempt to update for all providers."
            ALL_PROVIDERS="aws azure capa cloud-director kvm vsphere"
            echo "providers_list=${ALL_PROVIDERS}" >> "$GITHUB_OUTPUT"
          fi

      - name: Recreate release files
        id: recreate_release
        if: success() && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          set -o pipefail
          BRANCH_NAME="${{ steps.get_branch.outputs.result }}"
          PROVIDERS_TO_UPDATE="${{ steps.parse_command.outputs.provider }}${{ steps.parse_command.outputs.providers_list }}"

          # 1. Determine the release name from the branch.
          RELEASE_NAME=$(echo "$BRANCH_NAME" | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          if [[ -z "$RELEASE_NAME" ]]; then
            echo "Could not determine release name from branch '$BRANCH_NAME'. Aborting."
            exit 1
          fi

          FULL_LOG_CONTENT=""

          for PROVIDER in $PROVIDERS_TO_UPDATE; do
            echo "Processing provider: $PROVIDER"

            # 2. Determine the correct previous release to use as a base.
            search_dir=$PROVIDER
            if [ "$PROVIDER" == "aws" ]; then
                search_dir="capa"
            fi

            # Check if release directory for the given release name exists for the provider in the current branch
            if [ ! -d "$search_dir/$RELEASE_NAME" ]; then
              echo "Release '$RELEASE_NAME' does not exist for provider '$PROVIDER' (in directory '$search_dir'). Skipping."
              continue
            fi

            BASE_VERSION=$(find "$search_dir" -name "v*" -type d -not -path "*/archived/*" -exec basename {} \; | grep -v "^${RELEASE_NAME}$" | sort -V | tail -n 1)
            if [[ -z "$BASE_VERSION" ]]; then
              echo "Error: Could not determine base version for release '$RELEASE_NAME' for provider '$PROVIDER'."
              # Don't exit, just continue to the next provider
              continue
            fi
            echo "Updating release '$RELEASE_NAME' for provider '$PROVIDER' using base '$BASE_VERSION'"

            # 3. Recreate the release
            output=$(devctl release create \
              --base "$BASE_VERSION" \
              --name "$RELEASE_NAME" \
              --provider "$PROVIDER" \
              --bumpall \
              ${{ steps.parse_command.outputs.devctl_args }} \
              --overwrite -y --output markdown --requested-only 2>&1)

            # Check if devctl command was successful
            if [ $? -ne 0 ]; then
                FULL_LOG_CONTENT+="### Changes for ${PROVIDER^^}\n\n"
                FULL_LOG_CONTENT+="devctl command failed for provider $PROVIDER.\n\n"
                FULL_LOG_CONTENT+="<details><summary>Error Log</summary>\n\n"
                FULL_LOG_CONTENT+="_Output of \`devctl release create\`_: \n"
                FULL_LOG_CONTENT+="\`\`\`\n${output}\n\`\`\`\n\n"
                FULL_LOG_CONTENT+="</details>\n\n"
            else
                FULL_LOG_CONTENT+="### Changes for ${PROVIDER^^}\n\n"
                FULL_LOG_CONTENT+="${output}\n\n"
            fi
          done

          echo "log_content<<EOF" >> "$GITHUB_OUTPUT"
          echo "$FULL_LOG_CONTENT" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Commit and push changes
        if: success() && (steps.parse_command.outputs.provider || steps.parse_command.outputs.providers_list)
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email '41898282+github-actions[bot]@users.noreply.github.com'
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "chore: Update release files via comment"
            git push
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Add success reaction
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ github.event.comment.id }},
              content: '+1'
            })
      - name: Post devctl output as a comment
        if: steps.recreate_release.outputs.log_content != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = `${{ steps.recreate_release.outputs.log_content }}`;
            github.rest.issues.createComment({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });
