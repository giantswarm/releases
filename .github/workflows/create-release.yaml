name: Create Release PR

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release (major, minor, patch). Used if a specific version is not provided.'
        required: true
        type: choice
        default: 'minor'
        options:
          - major
          - minor
          - patch
      provider_all:
        description: 'Include all providers (AWS, Azure, Cloud Director, vSphere)'
        required: false
        type: boolean
        default: true
      provider_aws:
        description: 'Include AWS (CAPA) provider'
        required: false
        type: boolean
        default: false
      provider_azure:
        description: 'Include Azure (CAPZ) provider'
        required: false
        type: boolean
        default: false
      provider_cloud_director:
        description: 'Include Cloud Director (CAPVCD) provider'
        required: false
        type: boolean
        default: false
      provider_eks:
        description: 'Include EKS provider'
        required: false
        type: boolean
        default: false
      provider_vsphere:
        description: 'Include vSphere (CAPV) provider'
        required: false
        type: boolean
        default: false
      version:
        description: 'Specific version to create (e.g. v30.0.1). Overrides release_type.'
        required: false
        type: string
  schedule:
    - cron: '00 6 1 * *' # Run at 6:00 UTC on the first day of every month

jobs:
  dispatcher:
    name: "Dispatcher"
    runs-on: ubuntu-latest
    outputs:
      release_type: ${{ steps.dispatcher.outputs.release_type }}
      provider_matrix: ${{ steps.dispatcher.outputs.provider_matrix }}
      provider_list: ${{ steps.dispatcher.outputs.provider_list }}
      is_manual: ${{ steps.dispatcher.outputs.is_manual }}
      version_override: ${{ steps.dispatcher.outputs.version_override }}
      force_consolidated: ${{ steps.dispatcher.outputs.force_consolidated }}
      provider_count: ${{ steps.dispatcher.outputs.provider_count }}
    steps:
      - name: Determine release type and providers
        id: dispatcher
        run: |
          RELEASE_TYPE=""
          # Determine release type from triggers
          if [[ "${{ github.event_name }}" == 'workflow_dispatch' ]]; then
            echo "is_manual=true" >> "$GITHUB_OUTPUT"

            # Build provider list from boolean inputs
            SELECTED_PROVIDERS=""

            # Check if "all providers" is selected
            if [[ "${{ github.event.inputs.provider_all }}" == 'true' ]]; then
              SELECTED_PROVIDERS="aws,azure,cloud-director,eks,vsphere"
            else
              # Build list from individual provider selections
              if [[ "${{ github.event.inputs.provider_aws }}" == 'true' ]]; then
                SELECTED_PROVIDERS="${SELECTED_PROVIDERS}aws,"
              fi
              if [[ "${{ github.event.inputs.provider_azure }}" == 'true' ]]; then
                SELECTED_PROVIDERS="${SELECTED_PROVIDERS}azure,"
              fi
              if [[ "${{ github.event.inputs.provider_eks }}" == 'true' ]]; then
                SELECTED_PROVIDERS="${SELECTED_PROVIDERS}eks,"
              fi
              if [[ "${{ github.event.inputs.provider_cloud_director }}" == 'true' ]]; then
                SELECTED_PROVIDERS="${SELECTED_PROVIDERS}cloud-director,"
              fi
              if [[ "${{ github.event.inputs.provider_vsphere }}" == 'true' ]]; then
                SELECTED_PROVIDERS="${SELECTED_PROVIDERS}vsphere,"
              fi

              # Remove trailing comma
              SELECTED_PROVIDERS=$(echo "$SELECTED_PROVIDERS" | sed 's/,$//')
            fi

            PROVIDER_INPUT="$SELECTED_PROVIDERS"

            # Count providers
            if [[ "$PROVIDER_INPUT" == '' ]]; then
              PROVIDER_COUNT=0
            else
              PROVIDER_COUNT=$(echo "$PROVIDER_INPUT" | tr ',' ' ' | wc -w)
            fi
            echo "provider_count=$PROVIDER_COUNT" >> "$GITHUB_OUTPUT"

            # Set force_consolidated flag for manual runs with 0 or 2+ providers.
            if [[ $PROVIDER_COUNT -eq 1 ]]; then
              echo "force_consolidated=false" >> "$GITHUB_OUTPUT"
            else
              echo "force_consolidated=true" >> "$GITHUB_OUTPUT"
            fi

            if [[ "${{ github.event.inputs.version }}" != '' ]]; then
              echo "version_override=${{ github.event.inputs.version }}" >> "$GITHUB_OUTPUT"
              if [[ "${{ github.event.inputs.version }}" =~ \.[0-9]+\.[0-9]+$ ]]; then
                RELEASE_TYPE="patch"
              else
                RELEASE_TYPE="minor"
              fi
            else
              RELEASE_TYPE="${{ github.event.inputs.release_type }}"
              if [[ "$RELEASE_TYPE" == '' ]]; then
                RELEASE_TYPE="major"
              fi
            fi
            echo "release_type=$RELEASE_TYPE" >> "$GITHUB_OUTPUT"
          elif [[ "${{ github.event_name }}" == 'schedule' ]]; then
            echo "is_manual=false" >> "$GITHUB_OUTPUT"
            echo "force_consolidated=false" >> "$GITHUB_OUTPUT"
            echo "provider_count=0" >> "$GITHUB_OUTPUT" # Not relevant for scheduled runs, but set a default.

            # For scheduled runs, we'll create separate jobs for major and minor releases
            # The individual job deciders will handle the logic for when to run
            echo "release_type=major_and_minor" >> "$GITHUB_OUTPUT"
          fi

          # Determine provider matrix and list
          if [[ "${{ github.event_name }}" == 'workflow_dispatch' && "$PROVIDER_INPUT" != '' ]]; then
            # Manual run with a specific provider list.
            PROVIDER_JSON=$(echo "$PROVIDER_INPUT" | jq -R 'split(",")' | jq -c '.')
            echo "provider_matrix=${PROVIDER_JSON}" >> "$GITHUB_OUTPUT"
            PROVIDER_LIST=$(echo "$PROVIDER_INPUT" | sed 's/,/ /g')
            echo "provider_list=${PROVIDER_LIST}" >> "$GITHUB_OUTPUT"
          else
            # Default for all scheduled runs (major or minor) and manual runs without any selected providers.
            # When maintaining this list, please also update the provider boolean inputs in the workflow_dispatch inputs
            echo "provider_matrix=[\"aws\",\"azure\",\"cloud-director\",\"eks\",\"vsphere\"]" >> "$GITHUB_OUTPUT"
            echo "provider_list=aws azure cloud-director eks vsphere" >> "$GITHUB_OUTPUT"
          fi

  major_release_decider:
    name: "Major Release Decider"
    needs: [dispatcher]
    if: needs.dispatcher.outputs.release_type == 'major' || needs.dispatcher.outputs.release_type == 'major_and_minor'
    runs-on: ubuntu-latest
    outputs:
      run_consolidated: ${{ steps.decider.outputs.run_consolidated }}
      run_individual: ${{ steps.decider.outputs.run_individual }}
      provider_list: ${{ needs.dispatcher.outputs.provider_list }}
      provider_matrix: ${{ needs.dispatcher.outputs.provider_matrix }}
      version_override: ${{ needs.dispatcher.outputs.version_override }}
      release_type: ${{ needs.dispatcher.outputs.release_type }}
    steps:
      - uses: actions/checkout@v5
      - id: decider
        run: |
          IS_MANUAL='${{ needs.dispatcher.outputs.is_manual }}'
          FORCE_CONSOLIDATED='${{ needs.dispatcher.outputs.force_consolidated }}'
          ALIGNMENT="aligned" # Default to aligned for manual runs

          if [[ "$IS_MANUAL" == 'false' ]]; then
            echo "Scheduled run detected. Checking if there is an unreleased major version."
            # Check if there are already open (unreleased) PRs for the next major version
            chmod +x ./tools/check-major-version-merged.sh
            # Split the provider list into individual arguments
            PROVIDER_ARGS=(${{ needs.dispatcher.outputs.provider_list }})
            MERGED_STATUS=$(./tools/check-major-version-merged.sh "${PROVIDER_ARGS[@]}" | grep 'merged=' | cut -d'=' -f2)
            LATEST_MAJOR=$(./tools/check-major-version-merged.sh "${PROVIDER_ARGS[@]}" | grep 'latest_major=' | cut -d'=' -f2)
            NEXT_MAJOR=$(./tools/check-major-version-merged.sh "${PROVIDER_ARGS[@]}" | grep 'next_major=' | cut -d'=' -f2)

            # If merged=false, it means there's an unreleased major (open PR not yet merged)
            if [[ "$MERGED_STATUS" == "false" ]]; then
              echo "Found unreleased major version v$NEXT_MAJOR.0.0. Skipping major release creation."
              echo "A minor release will be created instead."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "No unreleased major found. Checking for existing major release PRs."

            # Check for existing OPEN PRs for the next major version
            CONSOLIDATED_PR=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "release-v$NEXT_MAJOR.0.0" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")
            INDIVIDUAL_PRS=()
            for provider in "${PROVIDER_ARGS[@]}"; do
              PR=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "release-v$NEXT_MAJOR.0.0-$provider" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")
              if [ -n "$PR" ]; then
                INDIVIDUAL_PRS+=("$provider")
              fi
            done

            if [ -n "$CONSOLIDATED_PR" ] || [ ${#INDIVIDUAL_PRS[@]} -gt 0 ]; then
              echo "Found existing PRs for v$NEXT_MAJOR.0.0. Skipping major release creation."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "No existing PRs found. Running pre-flight alignment check."
            chmod +x ./tools/check-major-version-alignment.sh
            # Split the provider list into individual arguments
            PROVIDER_ARGS=(${{ needs.dispatcher.outputs.provider_list }})
            echo "Provider args: ${PROVIDER_ARGS[*]}"
            ALIGNMENT_OUTPUT=$(./tools/check-major-version-alignment.sh "${PROVIDER_ARGS[@]}")
            echo "Alignment check output: $ALIGNMENT_OUTPUT"
            ALIGNMENT=$(echo "$ALIGNMENT_OUTPUT" | grep 'Alignment status:' | cut -d':' -f2 | xargs)
            echo "Alignment result: $ALIGNMENT"
          fi

          if [[ "$IS_MANUAL" == 'true' ]]; then
            if [[ "$FORCE_CONSOLIDATED" == 'true' ]]; then
              echo "Manual consolidated major run detected. Running consolidated job."
              echo "run_consolidated=true" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
            else
              echo "Manual single provider major run detected. Running individual job."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=true" >> "$GITHUB_OUTPUT"
            fi
          elif [[ "$IS_MANUAL" == 'false' ]]; then
            echo "Scheduled run detected. Checking pre-flight alignment."
            if [[ "$ALIGNMENT" == 'aligned' ]]; then
              echo "Providers are aligned. Running consolidated job."
              echo "run_consolidated=true" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
            else
              echo "Providers are misaligned. Running individual jobs."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=true" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "No valid condition met. No major release job will run."
            echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
            echo "run_individual=false" >> "$GITHUB_OUTPUT"
          fi

  minor_release_decider:
    name: "Minor Release Decider"
    needs: [dispatcher]
    if: needs.dispatcher.outputs.release_type == 'minor' || needs.dispatcher.outputs.release_type == 'major_and_minor'
    runs-on: ubuntu-latest
    outputs:
      run_consolidated: ${{ steps.decider.outputs.run_consolidated }}
      run_individual: ${{ steps.decider.outputs.run_individual }}
      provider_list: ${{ needs.dispatcher.outputs.provider_list }}
      provider_matrix: ${{ needs.dispatcher.outputs.provider_matrix }}
      version_override: ${{ needs.dispatcher.outputs.version_override }}
      release_type: ${{ needs.dispatcher.outputs.release_type }}
    steps:
      - uses: actions/checkout@v5
      - id: decider
        run: |
          IS_MANUAL='${{ needs.dispatcher.outputs.is_manual }}'
          FORCE_CONSOLIDATED='${{ needs.dispatcher.outputs.force_consolidated }}'
          ALIGNMENT="aligned" # Default to aligned for manual runs

          if [[ "$IS_MANUAL" == 'false' ]]; then
            echo "Scheduled run detected. Checking for existing minor release PRs."
            chmod +x ./tools/check-minor-release-prs.sh
            # Split the provider list into individual arguments
            PROVIDER_ARGS=(${{ needs.dispatcher.outputs.provider_list }})
            PRS_EXIST=$(./tools/check-minor-release-prs.sh "${PROVIDER_ARGS[@]}" | grep 'prs_exist=' | cut -d'=' -f2)

            if [[ "$PRS_EXIST" == "true" ]]; then
              echo "Found existing minor release PRs. Skipping minor release creation."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "No existing minor release PRs found. Running pre-flight alignment check."
            chmod +x ./tools/check-minor-version-alignment.sh
            # Split the provider list into individual arguments
            PROVIDER_ARGS=(${{ needs.dispatcher.outputs.provider_list }})
            echo "Provider args: ${PROVIDER_ARGS[*]}"
            ALIGNMENT_OUTPUT=$(./tools/check-minor-version-alignment.sh "${PROVIDER_ARGS[@]}")
            echo "Minor alignment check output: $ALIGNMENT_OUTPUT"
            ALIGNMENT=$(echo "$ALIGNMENT_OUTPUT" | grep 'Alignment status:' | cut -d':' -f2 | xargs)
            echo "Minor alignment result: $ALIGNMENT"
          fi

          if [[ "$IS_MANUAL" == 'true' ]]; then
            if [[ "$FORCE_CONSOLIDATED" == 'true' ]]; then
              echo "Manual consolidated minor run detected. Running consolidated job."
              echo "run_consolidated=true" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
            else
              echo "Manual single provider minor run detected. Running individual job."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=true" >> "$GITHUB_OUTPUT"
            fi
          elif [[ "$IS_MANUAL" == 'false' ]]; then
            echo "Scheduled run detected. Checking pre-flight alignment."
            if [[ "$ALIGNMENT" == 'aligned' ]]; then
              echo "Providers are aligned. Running consolidated job."
              echo "run_consolidated=true" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
            else
              echo "Providers are misaligned. Running individual jobs."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=true" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "No valid condition met. No minor release job will run."
            echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
            echo "run_individual=false" >> "$GITHUB_OUTPUT"
          fi

  patch_release_decider:
    name: "Patch Release Decider"
    needs: [dispatcher]
    if: needs.dispatcher.outputs.release_type == 'patch'
    runs-on: ubuntu-latest
    outputs:
      run_consolidated: ${{ steps.decider.outputs.run_consolidated }}
      run_individual: ${{ steps.decider.outputs.run_individual }}
      provider_list: ${{ needs.dispatcher.outputs.provider_list }}
      provider_matrix: ${{ needs.dispatcher.outputs.provider_matrix }}
      version_override: ${{ needs.dispatcher.outputs.version_override }}
      release_type: ${{ needs.dispatcher.outputs.release_type }}
    steps:
      - uses: actions/checkout@v5
      - id: decider
        run: |
          IS_MANUAL='${{ needs.dispatcher.outputs.is_manual }}'
          FORCE_CONSOLIDATED='${{ needs.dispatcher.outputs.force_consolidated }}'

          if [[ "$IS_MANUAL" == 'true' ]]; then
            if [[ "$FORCE_CONSOLIDATED" == 'true' ]]; then
              echo "Manual consolidated patch run detected. Running consolidated job."
              echo "run_consolidated=true" >> "$GITHUB_OUTPUT"
              echo "run_individual=false" >> "$GITHUB_OUTPUT"
            else
              echo "Manual single provider patch run detected. Running individual job."
              echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
              echo "run_individual=true" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "Patch releases are only supported for manual runs."
            echo "run_consolidated=false" >> "$GITHUB_OUTPUT"
            echo "run_individual=false" >> "$GITHUB_OUTPUT"
          fi

  # This is the job for creating a single, consolidated PR for a major release when all providers are aligned.
  major_release_consolidated:
    name: "Major Release (Consolidated)"
    needs: [major_release_decider]
    if: needs.major_release_decider.outputs.run_consolidated == 'true'
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ steps.create_pr.outputs.pull-request-url }}
    steps:
      - uses: actions/checkout@v5
      - name: Determine next release version
        id: determine_next_release
        run: |
          # For major release jobs, always use "major" as the release type
          chmod +x ./tools/determine-next-release.sh
          ./tools/determine-next-release.sh "" "major" ${{ needs.major_release_decider.outputs.version_override }}

      - name: Install devctl
        uses: ./.github/actions/install-devctl
        with:
          github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Check for new upstream Kubernetes version
        id: k8s_check
        # This check is only relevant for major releases that are not manual backports.
        if: needs.dispatcher.outputs.version_override == ''
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          chmod +x ./tools/check-new-k8s-version-exists.sh
          ./tools/check-new-k8s-version-exists.sh "${{ steps.determine_next_release.outputs.version }}"

      - name: Check for existing PR
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          PR_EXISTS=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "release-${{ steps.determine_next_release.outputs.version }}" --json number --jq '.[0].number')
          if [ -z "$PR_EXISTS" ]; then
            echo "PR_EXISTS=false" >> "$GITHUB_OUTPUT"
          else
            echo "PR_EXISTS=true" >> "$GITHUB_OUTPUT"
            echo "An open PR for this release already exists. Skipping."
          fi

      - name: Filter providers for release
        id: filter_providers
        if: steps.check_pr.outputs.PR_EXISTS == 'false' && (needs.dispatcher.outputs.release_type != 'major' || steps.k8s_check.outputs.VERSION_EXISTS == 'true')
        run: |
          chmod +x ./tools/filter-providers-for-release.sh
          ./tools/filter-providers-for-release.sh "${{ steps.determine_next_release.outputs.version }}" ${{ needs.major_release_decider.outputs.provider_list }}

          # Store the filtered provider list for use in subsequent steps
          FILTERED_PROVIDERS=$(./tools/filter-providers-for-release.sh "${{ steps.determine_next_release.outputs.version }}" ${{ needs.major_release_decider.outputs.provider_list }} | grep "^included_providers=" | cut -d'=' -f2)
          echo "filtered_providers=$FILTERED_PROVIDERS" >> "$GITHUB_OUTPUT"
          echo "Using filtered provider list: $FILTERED_PROVIDERS"

      - name: Create release files and get output
        id: create_release
        if: steps.check_pr.outputs.PR_EXISTS == 'false' && (needs.dispatcher.outputs.release_type != 'major' || steps.k8s_check.outputs.VERSION_EXISTS == 'true')
        env:
          OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          DEVCTL_UNSAFE_FORCE_VERSION: ${{ steps.install_devctl.outputs.version }}
          DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          set -o pipefail
          export OPSCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          export DEVCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          LOG_FILE="/tmp/release_output.log"
          touch $LOG_FILE
          first_provider=true
          for provider in ${{ steps.filter_providers.outputs.filtered_providers }}; do
            echo "--- Creating release for $provider ---"

            # Add a separator before each provider except the first one
            if [ "$first_provider" = true ]; then
              first_provider=false
            else
              echo "" >> $LOG_FILE
              echo "---" >> $LOG_FILE
              echo "" >> $LOG_FILE
            fi

            # Capitalize provider name for the heading
            PROVIDER_UPPER=$(echo "$provider" | awk '{print toupper($0)}')
            echo "<details><summary>Changes for ${PROVIDER_UPPER}</summary>" >> $LOG_FILE
            echo "" >> $LOG_FILE

            BASE_VERSION=$(./tools/determine-next-release.sh "$provider" "major" "${{ needs.major_release_decider.outputs.version_override }}" | grep '^base=' | cut -d'=' -f2)

            n=0
            until [ "$n" -ge 3 ]
            do
              devctl release create \
                --base "$BASE_VERSION" \
                --name "${{ steps.determine_next_release.outputs.version }}" \
                --provider "$provider" \
                --bumpall --overwrite -y --output markdown --changes-only 2>&1 | tee -a $LOG_FILE && break
              n=$((n+1))
              if [ "$n" -ge 3 ]; then
                  echo "The command has failed 3 times in a row. Aborting."
                  exit 1
              fi
              echo "Command failed. Retrying in 15 seconds..."
              sleep 15
            done
            echo "</details>" >> $LOG_FILE
          done

          LOG_CONTENT=$(cat /tmp/release_output.log)
          echo "LOG_CONTENT<<EOF" >> "$GITHUB_ENV"
          echo "$LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

          PROVIDER_LABELS=$(echo "${{ steps.filter_providers.outputs.filtered_providers }}" | tr ' ' '\n')
          echo "PROVIDER_LABELS<<EOF" >> "$GITHUB_OUTPUT"
          echo "$PROVIDER_LABELS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Update README.md
        id: update_readme
        if: steps.check_pr.outputs.PR_EXISTS == 'false' && (needs.dispatcher.outputs.release_type != 'major' || steps.k8s_check.outputs.VERSION_EXISTS == 'true')
        run: |
          for provider in ${{ steps.filter_providers.outputs.filtered_providers }}; do
            ./tools/update-readme.sh "$provider" "${{ steps.determine_next_release.outputs.version }}"
            echo "Successfully updated README.md with ${{ steps.determine_next_release.outputs.version }} for $provider"
          done

      - name: Create Pull Request
        id: create_pr
        if: steps.check_pr.outputs.PR_EXISTS == 'false' && (needs.dispatcher.outputs.release_type != 'major' || steps.k8s_check.outputs.VERSION_EXISTS == 'true')
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          title: "CAPI: Release ${{ steps.determine_next_release.outputs.version }}."
          body: |
            This PR creates the new CAPI **major release** `${{ steps.determine_next_release.outputs.version }}` for **all providers** (consolidated).

            Major releases include new Kubernetes versions, significant platform upgrades, and breaking changes across all CAPI providers.

            ðŸ“– **Need help?** Check out the [CAPI Release Drafting Guide](https://intranet.giantswarm.io/docs/product/releases/capi/capi-release-drafting/) for detailed instructions.

            ---

            ## Updating this Release

            To update the release files in this PR, comment with `/update-release` and provide arguments directly to `devctl`. For consolidated releases, you **must** specify which provider you are updating.
            If you do not specify a provider, the bot will automatically detect the provider from the PR files.
            Available providers: `aws`, `azure`, `cloud-director`, `eks`, `vsphere`.

            **Examples:**

            *   Update a single component for a specific provider:
                `/update-release --provider aws --component flatcar@4152.2.3`

            *   Update multiple components and apps for a specific provider:
                `/update-release --provider azure --component cluster-azure@2.4.1 --app azuredisk-csi-driver@1.32.9`

            *   Specify app dependencies using the `#` separator:
                `/update-release --provider aws --app my-app@1.2.3@@dependency1#dependency2`

            **Add descriptions:**

            *   Update README.md for specific provider:
                `/update-readme --provider aws "This major release includes Kubernetes 1.32 support, enhanced security features, and significant performance improvements. It introduces new platform capabilities and resolves several stability issues."`

            *   Update announcement.md for specific provider:
                `/update-announcement --provider aws "Workload cluster release v32.0.0 for CAPA includes Kubernetes 1.32 support and enhanced security features."`

            *   Update all providers (auto-detected):
                `/update-readme "This major release brings significant platform enhancements and stability improvements across all supported providers."`
          branch: "release-${{ steps.determine_next_release.outputs.version }}"
          labels: |
            release/major
            ${{ steps.create_release.outputs.PROVIDER_LABELS }}

      - name: Checkout PR branch for analysis
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          git fetch origin "release-${{ steps.determine_next_release.outputs.version }}"
          git checkout "release-${{ steps.determine_next_release.outputs.version }}"

      - name: Analyze Breaking Changes
        if: steps.create_pr.outputs.pull-request-number != ''
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          cd tools/breakingchanges
          go run ./cmd/detect
      
      - name: Post Breaking Changes Comment
        if: steps.create_pr.outputs.pull-request-number != '' && hashFiles('tools/breakingchanges/breaking-changes-report.md') != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const fs = require('fs');
            const reportPath = 'tools/breakingchanges/breaking-changes-report.md';
            if (fs.existsSync(reportPath)) {
              const comment = fs.readFileSync(reportPath, 'utf8');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
                body: comment
              });
            }

      - name: Add comment to PR with devctl output
        if: steps.create_pr.outputs.pull-request-number && steps.create_pr.outputs.pull-request-number != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = `${{ env.LOG_CONTENT }}`;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
              body: `${output.replace(/`/g, '\\`')}`
            });

      # - name: Trigger e2e tests
      #   if: steps.check_pr.outputs.PR_EXISTS == 'false' && steps.k8s_check.outputs.VERSION_EXISTS == 'true' && steps.create_pr.outputs.pull-request-number
      #   uses: ./.github/actions/trigger-e2e-tests
      #   with:
      #     pr_number: ${{ steps.create_pr.outputs.pull-request-number }}
      #     github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

  minor_release_consolidated:
    name: "Minor Release (Consolidated)"
    needs: [minor_release_decider]
    if: needs.minor_release_decider.outputs.run_consolidated == 'true'
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ steps.create_pr.outputs.pull-request-url }}
    steps:
      - uses: actions/checkout@v5
      - name: Determine next release version
        id: determine_next_release
        run: |
          ./tools/determine-next-release.sh "" "minor" ${{ needs.minor_release_decider.outputs.version_override }}

      - name: Install devctl
        uses: ./.github/actions/install-devctl
        with:
          github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Check for existing PR
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          PR_EXISTS=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "release-${{ steps.determine_next_release.outputs.version }}" --json number --jq '.[0].number')
          if [ -z "$PR_EXISTS" ]; then
            echo "PR_EXISTS=false" >> "$GITHUB_OUTPUT"
          else
            echo "PR_EXISTS=true" >> "$GITHUB_OUTPUT"
            echo "An open PR for this release already exists. Skipping."
          fi

      - name: Filter providers for release
        id: filter_providers
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        run: |
          chmod +x ./tools/filter-providers-for-release.sh
          ./tools/filter-providers-for-release.sh "${{ steps.determine_next_release.outputs.version }}" ${{ needs.minor_release_decider.outputs.provider_list }}

          # Store the filtered provider list for use in subsequent steps
          FILTERED_PROVIDERS=$(./tools/filter-providers-for-release.sh "${{ steps.determine_next_release.outputs.version }}" ${{ needs.minor_release_decider.outputs.provider_list }} | grep "^included_providers=" | cut -d'=' -f2)
          echo "filtered_providers=$FILTERED_PROVIDERS" >> "$GITHUB_OUTPUT"
          echo "Using filtered provider list: $FILTERED_PROVIDERS"

      - name: Create release files and get output
        id: create_release
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        env:
          OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          DEVCTL_UNSAFE_FORCE_VERSION: ${{ steps.install_devctl.outputs.version }}
          DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          set -o pipefail
          export OPSCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          export DEVCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          LOG_FILE="/tmp/release_output.log"
          touch $LOG_FILE
          first_provider=true
          for provider in ${{ steps.filter_providers.outputs.filtered_providers }}; do
            echo "--- Creating release for $provider ---"

            # Add a separator before each provider except the first one
            if [ "$first_provider" = true ]; then
              first_provider=false
            else
              echo "" >> $LOG_FILE
              echo "---" >> $LOG_FILE
              echo "" >> $LOG_FILE
            fi

            # Capitalize provider name for the heading
            PROVIDER_UPPER=$(echo "$provider" | awk '{print toupper($0)}')
            echo "<details><summary>Changes for ${PROVIDER_UPPER}</summary>" >> $LOG_FILE
            echo "" >> $LOG_FILE

            BASE_VERSION=$(./tools/determine-next-release.sh "$provider" "minor" "${{ needs.minor_release_decider.outputs.version_override }}" | grep '^base=' | cut -d'=' -f2)

            n=0
            until [ "$n" -ge 3 ]
            do
              devctl release create \
                --base "$BASE_VERSION" \
                --name "${{ steps.determine_next_release.outputs.version }}" \
                --provider "$provider" \
                --bumpall --overwrite -y --output markdown --changes-only 2>&1 | tee -a $LOG_FILE && break
              n=$((n+1))
              if [ "$n" -ge 3 ]; then
                  echo "The command has failed 3 times in a row. Aborting."
                  exit 1
              fi
              echo "Command failed. Retrying in 15 seconds..."
              sleep 15
            done
            echo "</details>" >> $LOG_FILE
          done

          LOG_CONTENT=$(cat /tmp/release_output.log)
          echo "LOG_CONTENT<<EOF" >> "$GITHUB_ENV"
          echo "$LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

          PROVIDER_LABELS=$(echo "${{ steps.filter_providers.outputs.filtered_providers }}" | tr ' ' '\n')
          echo "PROVIDER_LABELS<<EOF" >> "$GITHUB_OUTPUT"
          echo "$PROVIDER_LABELS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Update README.md
        id: update_readme
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        run: |
          for provider in ${{ steps.filter_providers.outputs.filtered_providers }}; do
            ./tools/update-readme.sh "$provider" "${{ steps.determine_next_release.outputs.version }}"
            echo "Successfully updated README.md with ${{ steps.determine_next_release.outputs.version }} for $provider"
          done

      - name: Create Pull Request
        id: create_pr
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          title: "CAPI: Release ${{ steps.determine_next_release.outputs.version }}."
          body: |
            This PR creates the new CAPI **minor release** `${{ steps.determine_next_release.outputs.version }}` for **all providers** (consolidated).

            Minor releases include component updates, bug fixes, and feature improvements across all CAPI providers without breaking changes.

            ðŸ“– **Need help?** Check out the [CAPI Release Drafting Guide](https://intranet.giantswarm.io/docs/product/releases/capi/capi-release-drafting/) for detailed instructions.

            ---

            ## Updating this Release

            To update the release files in this PR, comment with `/update-release` and provide arguments directly to `devctl`. For consolidated releases, you **must** specify which provider you are updating.
            If you do not specify a provider, the bot will automatically detect the provider from the PR files.
            Available providers: `aws`, `azure`, `cloud-director`, `eks`, `vsphere`.

            **Examples:**

            *   Update a single component for a specific provider:
                `/update-release --provider aws --component flatcar@4152.2.3`

            *   Update multiple components and apps for a specific provider:
                `/update-release --provider azure --component cluster-azure@2.4.1 --app azuredisk-csi-driver@1.32.9`

            *   Specify app dependencies using the `#` separator:
                `/update-release --provider aws --app my-app@1.2.3@@dependency1#dependency2`

            **Add descriptions:**

            *   Update README.md for specific provider:
                `/update-readme --provider aws "This release includes component updates, bug fixes, and performance improvements."`

            *   Update announcement.md for specific provider:
                `/update-announcement --provider aws "Workload cluster release includes important updates and improvements."`

            *   Update all providers (auto-detected):
                `/update-readme "This minor release brings component updates and improvements across all supported providers."`
          branch: "release-${{ steps.determine_next_release.outputs.version }}"
          labels: |
            release/minor
            ${{ steps.create_release.outputs.PROVIDER_LABELS }}
      
      - name: Checkout PR branch for analysis
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          git fetch origin "release-${{ steps.determine_next_release.outputs.version }}"
          git checkout "release-${{ steps.determine_next_release.outputs.version }}"

      - name: Analyze Breaking Changes
        if: steps.create_pr.outputs.pull-request-number != ''
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          cd tools/breakingchanges
          go run ./cmd/detect
      
      - name: Post Breaking Changes Comment
        if: steps.create_pr.outputs.pull-request-number != '' && hashFiles('tools/breakingchanges/breaking-changes-report.md') != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const fs = require('fs');
            const reportPath = 'tools/breakingchanges/breaking-changes-report.md';
            if (fs.existsSync(reportPath)) {
              const comment = fs.readFileSync(reportPath, 'utf8');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
                body: comment
              });
            }

      - name: Add comment to PR with devctl output
        if: steps.create_pr.outputs.pull-request-number && steps.create_pr.outputs.pull-request-number != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = `${{ env.LOG_CONTENT }}`;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
              body: `### Changes:\n\n${output.replace(/`/g, '\\`')}`
            });

      # - name: Trigger e2e tests
      #   if: steps.check_pr.outputs.PR_EXISTS == 'false' && steps.create_pr.outputs.pull-request-number
      #   uses: ./.github/actions/trigger-e2e-tests
      #   with:
      #     pr_number: ${{ steps.create_pr.outputs.pull-request-number }}
      #     github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

  # This is the job for creating individual PRs for a major release when providers are not aligned.
  major_release_individual:
    name: "Major Release (Individual)"
    needs: [major_release_decider]
    if: needs.major_release_decider.outputs.run_individual == 'true'
    strategy:
      matrix:
        provider: ${{ fromJSON(needs.major_release_decider.outputs.provider_matrix) }}
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ steps.create_pr.outputs.pull-request-url }}
    steps:
      - uses: actions/checkout@v5
      - name: Determine next release version
        id: determine_next_release
        run: |
          # For major release jobs, always use "major" as the release type
          ./tools/determine-next-release.sh "${{ matrix.provider }}" "major" ${{ needs.major_release_decider.outputs.version_override }}

      - name: Install devctl
        uses: ./.github/actions/install-devctl
        with:
          github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Check for new upstream Kubernetes version
        id: k8s_check
        # This check is only relevant for major releases that are not manual backports.
        if: needs.dispatcher.outputs.version_override == ''
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          chmod +x ./tools/check-new-k8s-version-exists.sh
          ./tools/check-new-k8s-version-exists.sh "${{ steps.determine_next_release.outputs.version }}"

      - name: Check for existing PR
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          PR_EXISTS=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "release-${{ steps.determine_next_release.outputs.version }}-${{ matrix.provider }}" --json number --jq '.[0].number')
          if [ -z "$PR_EXISTS" ]; then
            echo "PR_EXISTS=false" >> "$GITHUB_OUTPUT"
          else
            echo "PR_EXISTS=true" >> "$GITHUB_OUTPUT"
            echo "An open PR for this release already exists. Skipping."
          fi

      - name: Create release files and get output
        id: create_release
        if: steps.check_pr.outputs.PR_EXISTS == 'false' && (needs.dispatcher.outputs.release_type != 'major' || steps.k8s_check.outputs.VERSION_EXISTS == 'true')
        env:
          OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          DEVCTL_UNSAFE_FORCE_VERSION: ${{ steps.install_devctl.outputs.version }}
          DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          set -o pipefail
          export DEVCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          devctl release create \
            --base "${{ steps.determine_next_release.outputs.base }}" \
            --name "${{ steps.determine_next_release.outputs.version }}" \
            --provider "${{ matrix.provider }}" \
            --bumpall --overwrite -y --output markdown --changes-only 2>&1 | tee /tmp/release_output.log

          LOG_CONTENT=$(cat /tmp/release_output.log)
          echo "LOG_CONTENT<<EOF" >> "$GITHUB_ENV"
          echo "$LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Update README.md
        id: update_readme
        if: steps.check_pr.outputs.PR_EXISTS == 'false' && (needs.dispatcher.outputs.release_type != 'major' || steps.k8s_check.outputs.VERSION_EXISTS == 'true')
        run: |
          ./tools/update-readme.sh "${{ matrix.provider }}" "${{ steps.determine_next_release.outputs.version }}"

      - name: Create Pull Request
        id: create_pr
        if: steps.check_pr.outputs.PR_EXISTS == 'false' && (needs.dispatcher.outputs.release_type != 'major' || steps.k8s_check.outputs.VERSION_EXISTS == 'true')
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          title: "${{ steps.determine_next_release.outputs.provider_acronym }}: Release ${{ steps.determine_next_release.outputs.version }}."
          body: |
            This PR creates the new **major release** `${{ steps.determine_next_release.outputs.version }}` for **${{ matrix.provider }}** only.

            Major releases include new Kubernetes versions, significant platform upgrades, and breaking changes.

            ðŸ“– **Need help?** Check out the [CAPI Release Drafting Guide](https://intranet.giantswarm.io/docs/product/releases/capi/capi-release-drafting/) for detailed instructions.

            ---

            ## Updating this Release

            To update the release files in this PR, comment with `/update-release` and provide arguments directly to `devctl`.
            If you do not specify a provider, the bot will automatically detect the provider from the PR files.
            Available providers: `aws`, `azure`, `cloud-director`, `eks`, `vsphere`.

            **Examples:**

            *   Update a single component:
                `/update-release --component flatcar@4152.2.3`

            *   Update a single application:
                `/update-release --app aws-ebs-csi-driver@3.0.5`

            *   Update multiple components and apps at once:
                `/update-release --component cluster-aws@4.0.2 --app karpenter-bundle@2.2.0 --app coredns@1.27.0`

            *   Specify app dependencies using the `#` separator:
                `/update-release --app my-app@1.2.3@@dependency1#dependency2`

            **Add descriptions:**

            *   Update README.md with detailed description:
                `/update-readme "This major release includes Kubernetes 1.32 support, enhanced security features, and significant performance improvements. It introduces new platform capabilities and resolves several stability issues."`

            *   Update announcement.md with brief summary:
                `/update-announcement "Workload cluster release includes Kubernetes 1.32 support and enhanced security features."`
          branch: "release-${{ steps.determine_next_release.outputs.version }}-${{ matrix.provider }}"
          labels: |
            release/major
            ${{ matrix.provider }}
      
      - name: Checkout PR branch for analysis
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          git fetch origin "release-${{ steps.determine_next_release.outputs.version }}"
          git checkout "release-${{ steps.determine_next_release.outputs.version }}"

      - name: Analyze Breaking Changes
        if: steps.create_pr.outputs.pull-request-number != ''
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          cd tools/breakingchanges
          go run ./cmd/detect
      
      - name: Post Breaking Changes Comment
        if: steps.create_pr.outputs.pull-request-number != '' && hashFiles('tools/breakingchanges/breaking-changes-report.md') != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const fs = require('fs');
            const reportPath = 'tools/breakingchanges/breaking-changes-report.md';
            if (fs.existsSync(reportPath)) {
              const comment = fs.readFileSync(reportPath, 'utf8');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
                body: comment
              });
            }

      - name: Add comment to PR with devctl output
        if: steps.create_pr.outputs.pull-request-number && steps.create_pr.outputs.pull-request-number != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = `${{ env.LOG_CONTENT }}`;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
              body: `### Changes:\n\n${output.replace(/`/g, '\\`')}`
            });

      # - name: Trigger e2e tests
      #   if: steps.check_pr.outputs.PR_EXISTS == 'false' && steps.create_pr.outputs.pull-request-number
      #   uses: ./.github/actions/trigger-e2e-tests
      #   with:
      #     pr_number: ${{ steps.create_pr.outputs.pull-request-number }}
      #     github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

  minor_release_individual:
    name: "Minor Release (Individual)"
    needs: [minor_release_decider]
    if: needs.minor_release_decider.outputs.run_individual == 'true'
    strategy:
      matrix:
        provider: ${{ fromJSON(needs.minor_release_decider.outputs.provider_matrix) }}
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ steps.create_pr.outputs.pull-request-url }}
    steps:
      - uses: actions/checkout@v5
      - name: Determine next release version
        id: determine_next_release
        run: |
          # For minor release jobs, always use "minor" as the release type
          ./tools/determine-next-release.sh "${{ matrix.provider }}" "minor" ${{ needs.minor_release_decider.outputs.version_override }}

      - name: Install devctl
        uses: ./.github/actions/install-devctl
        with:
          github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Check for existing PR
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          PR_EXISTS=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "release-${{ steps.determine_next_release.outputs.version }}-${{ matrix.provider }}" --json number --jq '.[0].number')
          if [ -z "$PR_EXISTS" ]; then
            echo "PR_EXISTS=false" >> "$GITHUB_OUTPUT"
          else
            echo "PR_EXISTS=true" >> "$GITHUB_OUTPUT"
            echo "An open PR for this release already exists. Skipping."
          fi

      - name: Create release files and get output
        id: create_release
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        env:
          OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          DEVCTL_UNSAFE_FORCE_VERSION: ${{ steps.install_devctl.outputs.version }}
          DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          set -o pipefail
          export DEVCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          devctl release create \
            --base "${{ steps.determine_next_release.outputs.base }}" \
            --name "${{ steps.determine_next_release.outputs.version }}" \
            --provider "${{ matrix.provider }}" \
            --bumpall --overwrite -y --output markdown --changes-only 2>&1 | tee /tmp/release_output.log

          LOG_CONTENT=$(cat /tmp/release_output.log)
          echo "LOG_CONTENT<<EOF" >> "$GITHUB_ENV"
          echo "$LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: Update README.md
        id: update_readme
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        run: |
          ./tools/update-readme.sh "${{ matrix.provider }}" "${{ steps.determine_next_release.outputs.version }}"

      - name: Create Pull Request
        id: create_pr
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          title: "${{ steps.determine_next_release.outputs.provider_acronym }}: Release ${{ steps.determine_next_release.outputs.version }}."
          body: |
            This PR creates the new **minor release** `${{ steps.determine_next_release.outputs.version }}` for **${{ matrix.provider }}** only.

            Minor releases include component updates, bug fixes, and feature improvements without breaking changes.

            ðŸ“– **Need help?** Check out the [CAPI Release Drafting Guide](https://intranet.giantswarm.io/docs/product/releases/capi/capi-release-drafting/) for detailed instructions.

            ---

            ## Updating this Release

            To update the release files in this PR, comment with `/update-release` and provide arguments directly to `devctl`.
            If you do not specify a provider, the bot will automatically detect the provider from the PR files.
            Available providers: `aws`, `azure`, `cloud-director`, `eks`, `vsphere`.

            **Examples:**

            *   Update a single component:
                `/update-release --component flatcar@4152.2.3`

            *   Update a single application:
                `/update-release --app aws-ebs-csi-driver@3.0.5`

            *   Update multiple components and apps at once:
                `/update-release --component cluster-aws@4.0.2 --app karpenter-bundle@2.2.0 --app coredns@1.27.0`

            *   Specify app dependencies using the `#` separator:
                `/update-release --app my-app@1.2.3@@dependency1#dependency2`

            **Add descriptions:**

            *   Update README.md with detailed description:
                `/update-readme "This release includes component updates, bug fixes, and performance improvements."`

            *   Update announcement.md with brief summary:
                `/update-announcement "Workload cluster release includes important updates and improvements."`
          branch: "release-${{ steps.determine_next_release.outputs.version }}-${{ matrix.provider }}"
          labels: |
            release/minor
            ${{ matrix.provider }}
      
      - name: Checkout PR branch for analysis
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          git fetch origin "release-${{ steps.determine_next_release.outputs.version }}"
          git checkout "release-${{ steps.determine_next_release.outputs.version }}"

      - name: Analyze Breaking Changes
        if: steps.create_pr.outputs.pull-request-number != ''
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          cd tools/breakingchanges
          go run ./cmd/detect
      
      - name: Post Breaking Changes Comment
        if: steps.create_pr.outputs.pull-request-number != '' && hashFiles('tools/breakingchanges/breaking-changes-report.md') != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const fs = require('fs');
            const reportPath = 'tools/breakingchanges/breaking-changes-report.md';
            if (fs.existsSync(reportPath)) {
              const comment = fs.readFileSync(reportPath, 'utf8');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
                body: comment
              });
            }

      - name: Add comment to PR with devctl output
        if: steps.create_pr.outputs.pull-request-number && steps.create_pr.outputs.pull-request-number != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = `${{ env.LOG_CONTENT }}`;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
              body: `### Changes:\n\n${output.replace(/`/g, '\\`')}`
            });

  patch_release_individual:
    name: "Patch Release (Individual)"
    needs: [patch_release_decider]
    if: needs.patch_release_decider.outputs.run_individual == 'true'
    strategy:
      matrix:
        provider: ${{ fromJSON(needs.patch_release_decider.outputs.provider_matrix) }}
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ steps.create_pr.outputs.pull-request-url }}
    env:
      OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
    steps:
      - name: Check out code
        uses: actions/checkout@v5
      - name: Install devctl
        uses: ./.github/actions/install-devctl
        with:
          github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
      - name: Set provider display name for title
        id: provider_name
        run: |
          provider="${{ matrix.provider }}"
          name=""
          if [[ "$provider" == "aws" ]]; then
            name="CAPA"
          elif [[ "$provider" == "azure" ]]; then
            name="CAPZ"
          elif [[ "$provider" == "vsphere" ]]; then
            name="CAPV"
          elif [[ "$provider" == "cloud-director" ]]; then
            name="CAPVCD"
          else
            name=$(echo "$provider" | tr 'a-z' 'A-Z')
          fi
          echo "NAME=$name" >> $GITHUB_OUTPUT
      - name: Determine next release version
        id: versioning
        run: |
          ./tools/determine-next-release.sh ${{ matrix.provider }} ${{ needs.patch_release_decider.outputs.release_type }} ${{ needs.patch_release_decider.outputs.version_override }}
      - name: Check for existing PR
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          BRANCH_NAME="release-${{ steps.versioning.outputs.NEXT_RELEASE }}-${{ matrix.provider }}"
          PR_EXISTS=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "$BRANCH_NAME" --json number --jq '.[0].number')
          if [ -z "$PR_EXISTS" ]; then
            echo "No existing PR found for branch $BRANCH_NAME. Proceeding."
            echo "PR_EXISTS=false" >> $GITHUB_OUTPUT
          else
            echo "PR for branch $BRANCH_NAME already exists. Skipping provider ${{ matrix.provider }}."
            echo "PR_EXISTS=true" >> $GITHUB_OUTPUT
          fi
      - name: Create new release
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        id: create_release
        env:
          DEVCTL_UNSAFE_FORCE_VERSION: ${{ steps.install_devctl.outputs.version }}
          DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          set -o pipefail
          export DEVCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          devctl release create \
            --base ${{ steps.versioning.outputs.LATEST_RELEASE }} \
            --name ${{ steps.versioning.outputs.NEXT_RELEASE }} \
            --provider ${{ matrix.provider }} \
            --bumpall --overwrite -y --output markdown --changes-only 2>&1 | tee /tmp/release_output.log
      - name: Update README.md
        id: update_readme
        run: |
          ./tools/update-readme.sh "${{ matrix.provider }}" "${{ steps.versioning.outputs.NEXT_RELEASE }}"
      - name: Prepare PR body
        id: pr_body
        run: |
          body="This PR creates the new **patch release** \`${{ steps.versioning.outputs.NEXT_RELEASE }}\` for **${{ matrix.provider }}** only.

          Patch releases contain targeted fixes for specific security issues, critical bugs, or component updates.

          ðŸ“– **Need help?** Check out the [CAPI Release Drafting Guide](https://intranet.giantswarm.io/docs/product/releases/capi/capi-release-drafting/) for detailed instructions.

          ---

          ## Updating this Release

          **Note:** For patch releases, it does not automatically bump any component or app.
          To update specific components or apps, comment with \`/update-release\` and provide arguments directly to \`devctl\`.
          If you do not specify a provider, the bot will automatically detect the provider from the PR files.
          Available providers: \`aws\`, \`azure\`, \`cloud-director\`, \`eks\`, \`vsphere\`.

          **Examples:**

          *   Update a single component:
              \`/update-release --component flatcar@4152.2.3\`

          *   Update a single application:
              \`/update-release --app aws-ebs-csi-driver@3.0.5\`

          *   Update multiple components and apps at once:
              \`/update-release --component kubernetes@1.31.8 --app security-bundle@1.12.1\`

          *   Specify app dependencies using the \`#\` separator:
              \`/update-release --app my-app@1.2.3@@dependency1#dependency2\`

          **Add descriptions:**

          *   Update README.md with detailed description:
              \`/update-readme \"This patch release fixes CVE-2024-1234 in security-bundle and updates Flatcar for hardware compatibility. It also resolves boot issues on certain hardware configurations.\"\`

          *   Update announcement.md with brief summary:
              \`/update-announcement \"Workload cluster release fixes critical security vulnerabilities and improves system stability.\"\`"
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$body" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Create Pull Request
        id: create_pr
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          commit-message: "feat: Create ${{ steps.versioning.outputs.NEXT_RELEASE }} for ${{ matrix.provider }}"
          title: "${{ steps.provider_name.outputs.NAME }}: Release ${{ steps.versioning.outputs.NEXT_RELEASE }}."
          body: ${{ steps.pr_body.outputs.body }}
          branch: "release-${{ steps.versioning.outputs.NEXT_RELEASE }}-${{ matrix.provider }}"
          labels: |
            release/${{ needs.patch_release_decider.outputs.release_type }}
            ${{ matrix.provider }}
      
      - name: Checkout PR branch for analysis
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          git fetch origin "release-${{ steps.determine_next_release.outputs.version }}"
          git checkout "release-${{ steps.determine_next_release.outputs.version }}"

      - name: Analyze Breaking Changes
        if: steps.create_pr.outputs.pull-request-number != ''
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          cd tools/breakingchanges
          go run ./cmd/detect
      
      - name: Post Breaking Changes Comment
        if: steps.create_pr.outputs.pull-request-number != '' && hashFiles('tools/breakingchanges/breaking-changes-report.md') != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const fs = require('fs');
            const reportPath = 'tools/breakingchanges/breaking-changes-report.md';
            if (fs.existsSync(reportPath)) {
              const comment = fs.readFileSync(reportPath, 'utf8');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
                body: comment
              });
            }

  patch_release_consolidated:
    name: "Patch Release (Consolidated)"
    needs: [patch_release_decider]
    if: needs.patch_release_decider.outputs.run_consolidated == 'true'
    runs-on: ubuntu-latest
    outputs:
      pr_url: ${{ steps.create_pr.outputs.pull-request-url }}
    steps:
      - uses: actions/checkout@v5
      - name: Determine next release version
        id: determine_next_release
        run: |
          ./tools/determine-next-release.sh "" "patch" ${{ needs.patch_release_decider.outputs.version_override }}

      - name: Install devctl
        uses: ./.github/actions/install-devctl
        with:
          github_token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}

      - name: Check for existing PR
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          PR_EXISTS=$(gh pr list --repo "$GITHUB_REPOSITORY" --head "release-${{ steps.determine_next_release.outputs.version }}" --json number --jq '.[0].number')
          if [ -z "$PR_EXISTS" ]; then
            echo "PR_EXISTS=false" >> "$GITHUB_OUTPUT"
          else
            echo "PR_EXISTS=true" >> "$GITHUB_OUTPUT"
            echo "An open PR for this release already exists. Skipping."
          fi

      - name: Filter providers for release
        id: filter_providers
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        run: |
          chmod +x ./tools/filter-providers-for-release.sh
          ./tools/filter-providers-for-release.sh "${{ steps.determine_next_release.outputs.version }}" ${{ needs.patch_release_decider.outputs.provider_list }}

          # Store the filtered provider list for use in subsequent steps
          FILTERED_PROVIDERS=$(./tools/filter-providers-for-release.sh "${{ steps.determine_next_release.outputs.version }}" ${{ needs.patch_release_decider.outputs.provider_list }} | grep "^included_providers=" | cut -d'=' -f2)
          echo "filtered_providers=$FILTERED_PROVIDERS" >> "$GITHUB_OUTPUT"
          echo "Using filtered provider list: $FILTERED_PROVIDERS"

      - name: Create release files and get output
        id: create_release
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        env:
          OPSCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          DEVCTL_UNSAFE_FORCE_VERSION: ${{ steps.install_devctl.outputs.version }}
          DEVCTL_GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          set -o pipefail
          export OPSCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          export DEVCTL_GITHUB_TOKEN=${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          LOG_FILE="/tmp/release_output.log"
          touch $LOG_FILE
          first_provider=true
          for provider in ${{ steps.filter_providers.outputs.filtered_providers }}; do
            echo "--- Creating release for $provider ---"

            # Add a separator before each provider except the first one
            if [ "$first_provider" = true ]; then
              first_provider=false
            else
              echo "" >> $LOG_FILE
              echo "---" >> $LOG_FILE
              echo "" >> $LOG_FILE
            fi

            # Capitalize provider name for the heading
            PROVIDER_UPPER=$(echo "$provider" | awk '{print toupper($0)}')
            echo "<details><summary>Changes for ${PROVIDER_UPPER}</summary>" >> $LOG_FILE
            echo "" >> $LOG_FILE

            BASE_VERSION=$(./tools/determine-next-release.sh "$provider" "patch" "${{ needs.patch_release_decider.outputs.version_override }}" | grep '^base=' | cut -d'=' -f2)

            n=0
            until [ "$n" -ge 3 ]
            do
              devctl release create \
                --base "$BASE_VERSION" \
                --name "${{ steps.determine_next_release.outputs.version }}" \
                --provider "$provider" \
                --bumpall --overwrite -y --output markdown --changes-only 2>&1 | tee -a $LOG_FILE && break
              n=$((n+1))
              if [ "$n" -ge 3 ]; then
                  echo "The command has failed 3 times in a row. Aborting."
                  exit 1
              fi
              echo "Command failed. Retrying in 15 seconds..."
              sleep 15
            done
            echo "</details>" >> $LOG_FILE
          done

          LOG_CONTENT=$(cat /tmp/release_output.log)
          echo "LOG_CONTENT<<EOF" >> "$GITHUB_ENV"
          echo "$LOG_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

          PROVIDER_LABELS=$(echo "${{ steps.filter_providers.outputs.filtered_providers }}" | tr ' ' '\n')
          echo "PROVIDER_LABELS<<EOF" >> "$GITHUB_OUTPUT"
          echo "$PROVIDER_LABELS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Update README.md
        id: update_readme
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        run: |
          for provider in ${{ steps.filter_providers.outputs.filtered_providers }}; do
            ./tools/update-readme.sh "$provider" "${{ steps.determine_next_release.outputs.version }}"
            echo "Successfully updated README.md with ${{ steps.determine_next_release.outputs.version }} for $provider"
          done

      - name: Create Pull Request
        id: create_pr
        if: steps.check_pr.outputs.PR_EXISTS == 'false'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          title: "CAPI: Release ${{ steps.determine_next_release.outputs.version }}."
          body: |
            This PR creates the new CAPI **patch release** `${{ steps.determine_next_release.outputs.version }}` for **all providers** (consolidated).

            Patch releases contain targeted fixes for specific security issues, critical bugs, or component updates.

            ðŸ“– **Need help?** Check out the [CAPI Release Drafting Guide](https://intranet.giantswarm.io/docs/product/releases/capi/capi-release-drafting/) for detailed instructions.

            ---

            ## Updating this Release

            **Note:** For patch releases, it does not automatically bump any component or app.
            To update the release files in this PR, comment with `/update-release` and provide arguments directly to `devctl`. For consolidated releases, you **must** specify which provider you are updating.
            If you do not specify a provider, the bot will automatically detect the provider from the PR files.
            Available providers: `aws`, `azure`, `cloud-director`, `eks`, `vsphere`.

            **Examples:**

            *   Update a single component for a specific provider:
                `/update-release --provider aws --component flatcar@4152.2.3`

            *   Update multiple components and apps for a specific provider:
                `/update-release --provider azure --component cluster-azure@2.4.1 --app azuredisk-csi-driver@1.32.9`

            *   Specify app dependencies using the `#` separator:
                `/update-release --provider aws --app my-app@1.2.3@@dependency1#dependency2`

            **Add descriptions:**

            *   Update README.md for specific provider:
                `/update-readme --provider aws "This patch release fixes CVE-2024-1234 in security-bundle and updates Flatcar for hardware compatibility. It also resolves boot issues on certain hardware configurations."`

            *   Update announcement.md for specific provider:
                `/update-announcement --provider aws "Workload cluster release fixes critical security vulnerabilities and improves system stability."`

            *   Update all providers (auto-detected):
                `/update-readme "This patch release brings important security fixes and stability improvements across all supported providers."`
          branch: "release-${{ steps.determine_next_release.outputs.version }}"
          labels: |
            release/${{ needs.patch_release_decider.outputs.release_type }}
            ${{ steps.create_release.outputs.PROVIDER_LABELS }}
      
      - name: Checkout PR branch for analysis
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          git fetch origin "release-${{ steps.determine_next_release.outputs.version }}"
          git checkout "release-${{ steps.determine_next_release.outputs.version }}"

      - name: Analyze Breaking Changes
        if: steps.create_pr.outputs.pull-request-number != ''
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          PR_NUMBER: ${{ steps.create_pr.outputs.pull-request-number }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          cd tools/breakingchanges
          go run ./cmd/detect
      
      - name: Post Breaking Changes Comment
        if: steps.create_pr.outputs.pull-request-number != '' && hashFiles('tools/breakingchanges/breaking-changes-report.md') != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const fs = require('fs');
            const reportPath = 'tools/breakingchanges/breaking-changes-report.md';
            if (fs.existsSync(reportPath)) {
              const comment = fs.readFileSync(reportPath, 'utf8');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
                body: comment
              });
            }

      - name: Add comment to PR with devctl output
        if: steps.create_pr.outputs.pull-request-number && steps.create_pr.outputs.pull-request-number != ''
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
          script: |
            const output = `${{ env.LOG_CONTENT }}`;
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create_pr.outputs.pull-request-number }},
              body: `${output.replace(/`/g, '\\`')}`
            });

  summarize_releases:
    name: "Summarize Releases"
    needs:
      - major_release_consolidated
      - minor_release_consolidated
      - major_release_individual
      - minor_release_individual
      - patch_release_individual
      - patch_release_consolidated
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v5

      - name: "Generate release summary"
        id: generate_summary
        run: |
          SUMMARY_CONTENT="## Release Summary\n\n"

          # Consolidated Major Releases
          if [[ "${{ needs.major_release_consolidated.outputs.pr_url }}" != "" ]]; then
            SUMMARY_CONTENT="${SUMMARY_CONTENT}**Consolidated Major Release PR:**\n"
            SUMMARY_CONTENT="${SUMMARY_CONTENT}- ${{ needs.major_release_consolidated.outputs.pr_url }}\n\n"
          fi

          # Consolidated Minor Releases
          if [[ "${{ needs.minor_release_consolidated.outputs.pr_url }}" != "" ]]; then
            SUMMARY_CONTENT="${SUMMARY_CONTENT}**Consolidated Minor Release PR:**\n"
            SUMMARY_CONTENT="${SUMMARY_CONTENT}- ${{ needs.minor_release_consolidated.outputs.pr_url }}\n\n"
          fi

          # Individual Major Releases
          MAJOR_INDIVIDUAL_RELEASES=$(echo '${{ toJSON(needs.major_release_individual) }}' | jq -r '(if has("result") then . else .[] end) | select(.result == "success") | .outputs.pr_url')
          if [[ "$MAJOR_INDIVIDUAL_RELEASES" != "" ]]; then
            SUMMARY_CONTENT="${SUMMARY_CONTENT}**Individual Major Release PRs:**\n"
            for url in $MAJOR_INDIVIDUAL_RELEASES; do
              SUMMARY_CONTENT="${SUMMARY_CONTENT}- $url\n"
            done
            SUMMARY_CONTENT="${SUMMARY_CONTENT}\n"
          fi

          # Individual Minor Releases
          MINOR_INDIVIDUAL_RELEASES=$(echo '${{ toJSON(needs.minor_release_individual) }}' | jq -r '(if has("result") then . else .[] end) | select(.result == "success") | .outputs.pr_url')
          if [[ "$MINOR_INDIVIDUAL_RELEASES" != "" ]]; then
            SUMMARY_CONTENT="${SUMMARY_CONTENT}**Individual Minor Release PRs:**\n"
            for url in $MINOR_INDIVIDUAL_RELEASES; do
              SUMMARY_CONTENT="${SUMMARY_CONTENT}- $url\n"
            done
            SUMMARY_CONTENT="${SUMMARY_CONTENT}\n"
          fi


          # Consolidated Patch Releases
          if [[ "${{ needs.patch_release_consolidated.outputs.pr_url }}" != "" ]]; then
            SUMMARY_CONTENT="${SUMMARY_CONTENT}**Consolidated Patch Release PR:**\n"
            SUMMARY_CONTENT="${SUMMARY_CONTENT}- ${{ needs.patch_release_consolidated.outputs.pr_url }}\n\n"
          fi

          # Individual Patch Releases
          PATCH_INDIVIDUAL_RELEASES=$(echo '${{ toJSON(needs.patch_release_individual) }}' | jq -r '(if has("result") then . else .[] end) | select(.result == "success") | .outputs.pr_url')
          if [[ "$PATCH_INDIVIDUAL_RELEASES" != "" ]]; then
            SUMMARY_CONTENT="${SUMMARY_CONTENT}**Individual Patch Release PRs:**\n"
            for url in $PATCH_INDIVIDUAL_RELEASES; do
              SUMMARY_CONTENT="${SUMMARY_CONTENT}- $url\n"
            done
            SUMMARY_CONTENT="${SUMMARY_CONTENT}\n"
          fi

          echo "SUMMARY_CONTENT<<EOF" >> "$GITHUB_ENV"
          echo "$SUMMARY_CONTENT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"

      - name: "Post job summary"
        run: |
          printf "%b" "${{ env.SUMMARY_CONTENT }}" >> $GITHUB_STEP_SUMMARY

  announce_scheduled_release:
    name: "Announce Scheduled Release"
    needs:
      - dispatcher
      - summarize_releases
      - major_release_consolidated
      - minor_release_consolidated
      - major_release_individual
      - minor_release_individual
    # Only announce for scheduled (non-manual) releases that successfully created PRs
    if: |
      always() &&
      needs.dispatcher.outputs.is_manual == 'false' &&
      (needs.major_release_consolidated.result == 'success' ||
       needs.minor_release_consolidated.result == 'success' ||
       needs.major_release_individual.result == 'success' ||
       needs.minor_release_individual.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v5

      - name: "Prepare Slack announcement"
        id: prepare_announcement
        env:
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          # Extract release version from PR URLs
          RELEASE_VERSION=""

          # Try to get version from consolidated PRs first
          if [[ "${{ needs.major_release_consolidated.outputs.pr_url }}" != "" ]]; then
            PR_URL="${{ needs.major_release_consolidated.outputs.pr_url }}"
            PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
            RELEASE_VERSION=$(gh pr view "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --json headRefName --jq '.headRefName' | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          elif [[ "${{ needs.minor_release_consolidated.outputs.pr_url }}" != "" ]]; then
            PR_URL="${{ needs.minor_release_consolidated.outputs.pr_url }}"
            PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
            RELEASE_VERSION=$(gh pr view "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --json headRefName --jq '.headRefName' | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
          else
            # Try to get from individual PRs
            MAJOR_INDIVIDUAL_RELEASES=$(echo '${{ toJSON(needs.major_release_individual) }}' | jq -r '(if has("result") then . else .[] end) | select(.result == "success") | .outputs.pr_url' 2>/dev/null || true)
            MINOR_INDIVIDUAL_RELEASES=$(echo '${{ toJSON(needs.minor_release_individual) }}' | jq -r '(if has("result") then . else .[] end) | select(.result == "success") | .outputs.pr_url' 2>/dev/null || true)

            FIRST_URL=""
            if [[ "$MAJOR_INDIVIDUAL_RELEASES" != "" ]]; then
              FIRST_URL=$(echo "$MAJOR_INDIVIDUAL_RELEASES" | head -n 1)
            elif [[ "$MINOR_INDIVIDUAL_RELEASES" != "" ]]; then
              FIRST_URL=$(echo "$MINOR_INDIVIDUAL_RELEASES" | head -n 1)
            fi

            if [[ "$FIRST_URL" != "" ]]; then
              PR_NUMBER=$(echo "$FIRST_URL" | grep -oE '[0-9]+$')
              RELEASE_VERSION=$(gh pr view "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --json headRefName --jq '.headRefName' | sed -n 's/release-\(v[0-9.]*\).*/\1/p')
            fi
          fi

          echo "Detected release version: $RELEASE_VERSION"
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> "$GITHUB_ENV"

          # Determine release type
          RELEASE_TYPE="Release"
          if [[ "${{ needs.dispatcher.outputs.release_type }}" == "major_and_minor" ]]; then
            # Check which actually ran
            if [[ "${{ needs.major_release_consolidated.result }}" == "success" ]] || [[ "${{ needs.major_release_individual.result }}" == "success" ]]; then
              RELEASE_TYPE="Major Release"
            elif [[ "${{ needs.minor_release_consolidated.result }}" == "success" ]] || [[ "${{ needs.minor_release_individual.result }}" == "success" ]]; then
              RELEASE_TYPE="Minor Release"
            fi
          elif [[ "${{ needs.dispatcher.outputs.release_type }}" == "major" ]]; then
            RELEASE_TYPE="Major Release"
          elif [[ "${{ needs.dispatcher.outputs.release_type }}" == "minor" ]]; then
            RELEASE_TYPE="Minor Release"
          fi

          echo "RELEASE_TYPE=$RELEASE_TYPE" >> "$GITHUB_ENV"

      - name: "Send Slack notification"
        id: send_slack
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_RELEASE_CHANNEL_ID }}
          GH_TOKEN: ${{ secrets.TAYLORBOT_GITHUB_ACTION }}
        run: |
          # Skip if Slack is not configured
          if [[ -z "$SLACK_BOT_TOKEN" ]] || [[ -z "$SLACK_CHANNEL_ID" ]]; then
            echo "Slack is not configured. Skipping notification."
            exit 0
          fi
          # Build Slack message with release version if available
          if [[ -n "${{ env.RELEASE_VERSION }}" ]]; then
            SLACK_TITLE="ðŸ“¢ Scheduled Release ${{ env.RELEASE_VERSION }} Available"
          else
            SLACK_TITLE="ðŸ“¢ Scheduled Release PR Available"
          fi

          # Get the PR URL from whichever job created it (only one PR is ever created)
          PR_URL=$(echo '${{ toJSON(needs.*.outputs.pr_url) }}' | jq -r 'to_entries[] | .value | select(. != null and . != "")' | head -n 1)

          echo "Found PR URL: $PR_URL"

          # Fetch the PR title using GitHub API
          if [[ -n "$PR_URL" ]]; then
            PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
            PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --json title --jq '.title')
            echo "PR Title: $PR_TITLE"
          else
            echo "Error: No PR URL found"
            exit 1
          fi

          # Create Slack payload
          SLACK_PAYLOAD=$(cat <<EOF
          {
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "$SLACK_TITLE",
                  "emoji": true
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "The scheduled workload cluster release PR has been created and is now ready for product teams to add their changes.\n\n*Release PR:* <$PR_URL|$PR_TITLE>"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": ":book: *Need help adding changes?*\nCheck out the <https://intranet.giantswarm.io/docs/product/releases/capi/capi-release-drafting/|CAPI Release Drafting Guide> for detailed instructions on how to update releases."
                }
              }
            ]
          }
          EOF
          )

          # Send to Slack using Bot Token
          echo "Sending to Slack using Bot Token"
          RESPONSE=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
            -d "{\"channel\": \"$SLACK_CHANNEL_ID\", \"blocks\": $(echo "$SLACK_PAYLOAD" | jq -c '.blocks'), \"metadata\": {\"event_type\": \"release_announcement\", \"event_payload\": {\"version\": \"${{ env.RELEASE_VERSION }}\", \"type\": \"${{ env.RELEASE_TYPE }}\"}}}")

          # Extract message timestamp for later updates
          MESSAGE_TS=$(echo "$RESPONSE" | jq -r '.ts')
          echo "MESSAGE_TS=$MESSAGE_TS" >> "$GITHUB_OUTPUT"
          echo "SLACK_CHANNEL=$SLACK_CHANNEL_ID" >> "$GITHUB_OUTPUT"
          echo "Slack message sent with timestamp: $MESSAGE_TS"

  notify_failure:
    name: "Notify on Failure"
    needs:
      - major_release_consolidated
      - minor_release_consolidated
      - major_release_individual
      - minor_release_individual
      - patch_release_individual
      - patch_release_consolidated
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: "Send failure notification"
        run: |
          echo "## :x: Release Workflow Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "One or more release jobs failed. Please check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Failed job(s):" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.major_release_consolidated.result }}" == "failure" ]]; then
            echo "- Major Release (Consolidated)" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ needs.minor_release_consolidated.result }}" == "failure" ]]; then
            echo "- Minor Release (Consolidated)" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ needs.major_release_individual.result }}" == "failure" ]]; then
            echo "- Major Release (Individual)" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ needs.minor_release_individual.result }}" == "failure" ]]; then
            echo "- Minor Release (Individual)" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ needs.patch_release_individual.result }}" == "failure" ]]; then
            echo "- Patch Release (Individual)" >> $GITHUB_STEP_SUMMARY
          fi
          if [[ "${{ needs.patch_release_consolidated.result }}" == "failure" ]]; then
            echo "- Patch Release (Consolidated)" >> $GITHUB_STEP_SUMMARY
          fi
