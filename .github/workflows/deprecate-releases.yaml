name: Deprecate Outdated Releases

on:
  # Run weekly on Monday morning
  schedule:
    - cron: "0 6 * * 1" # Every Monday at 6:00 AM UTC

  # Allow manual triggering
  workflow_dispatch:
  push:
    branches:
      - "master"
      - "main"
      - "release-deprecation"
    paths:
      - ".github/workflows/deprecate-releases.yaml"
      - "azure/**"
      - "capa/**"
      - "cloud-director/**"
      - "eks/**"
      - "vsphere/**"

jobs:
  deprecate-releases:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get provider lists
        id: providers
        uses: ./.github/actions/get-providers

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"

      - name: Build deprecation tool
        run: |
          cd tools
          go mod tidy
          go build -o $GITHUB_WORKSPACE/deprecate-releases deprecate-release.go
          cd $GITHUB_WORKSPACE

      - name: Run deprecation tool for all providers
        id: deprecation
        run: |
          PROVIDERS="${{ steps.providers.outputs.provider_dirs }}"
          
          for PROVIDER in $PROVIDERS; do
            if [ -d "$PROVIDER" ]; then
              echo "Processing provider: $PROVIDER"
              ./deprecate-releases -provider "$PROVIDER" -verbose -grafana-api-key="${{ secrets.GRAFANA_API_KEY }}" || true
            else
              echo "Skipping provider $PROVIDER (directory not found)"
            fi
          done
        env:
          GRAFANA_API_KEY: ${{ secrets.GRAFANA_API_KEY }}

      - name: Update releases.json files
        run: |
          PROVIDERS="${{ steps.providers.outputs.provider_dirs }}"
          
          for PROVIDER in $PROVIDERS; do
            RELEASES_JSON="${PROVIDER}/releases.json"
            if [ -f "$RELEASES_JSON" ]; then
              echo "Updating deprecation status in $RELEASES_JSON"

              # Create a temporary file to store the updated JSON
              TMP_JSON=$(mktemp)

              # For each changed release.yaml file in this provider, update the corresponding entry in releases.json
              for file in $(git diff --name-only | grep -E "^${PROVIDER}/.*release\.yaml$"); do
                # Extract version from directory name
                dir=$(dirname "$file")
                version=$(basename "$dir" | sed 's/^v//')

                echo "Checking if $version needs to be marked as deprecated in releases.json"

                # Check if this release is now deprecated
                if grep -q "state: deprecated" "$file"; then
                  echo "Marking version $version as deprecated in releases.json"

                  # Use jq to update the isDeprecated flag for this version
                  jq --arg ver "$version" '.releases |= map(if .version == $ver then .isDeprecated = true else . end)' "$RELEASES_JSON" > "$TMP_JSON"
                  mv "$TMP_JSON" "$RELEASES_JSON"
                fi
              done
            fi
          done

      - name: Keep only release files changes
        run: |
          # Remove the binary
          rm -f deprecate-releases

          # Identify changed files that are not release-related
          for file in $(git diff --name-only); do
            # Keep only release.yaml files and releases.json
            if [[ ! "$file" =~ .*release\.yaml$ ]] && [[ ! "$file" =~ .*releases\.json$ ]]; then
              git checkout -- "$file"
              echo "Reset changes to: $file"
            fi
          done

      - name: Prepare changed files list
        id: changed-files
        run: |
          # Ensure we're looking at the latest git state
          git add -A
          
          # Get changed release.yaml files (these are the ones that were deprecated)
          DEPRECATED_RELEASE_YAML_FILES=$(git diff --cached --name-only | grep -E ".*release\.yaml$" || echo "")

          # Get changed releases.json files
          RELEASES_JSON_FILES=$(git diff --cached --name-only | grep -E ".*releases\.json$" || echo "")

          if [[ -n "$DEPRECATED_RELEASE_YAML_FILES" || -n "$RELEASES_JSON_FILES" ]]; then
            # Build PR body
            PR_BODY=""
            
            if [[ -n "$RELEASES_JSON_FILES" ]]; then
              PR_BODY="${PR_BODY}### Modified Configuration\n\n"
              for json_file in $RELEASES_JSON_FILES; do
                PR_BODY="${PR_BODY}- \`$json_file\` - Updated deprecated status for relevant versions.\n"
              done
              PR_BODY="${PR_BODY}\n"
            fi

            if [[ -n "$DEPRECATED_RELEASE_YAML_FILES" ]]; then
              PR_BODY="${PR_BODY}### Releases Deprecated in this PR\n\n"

              # Group by provider
              PROVIDERS="${{ steps.providers.outputs.provider_dirs }}"
              
              for PROVIDER in $PROVIDERS; do
                # Get deprecated versions for this provider
                PROVIDER_DEPRECATED_FILES=$(echo "$DEPRECATED_RELEASE_YAML_FILES" | grep "^${PROVIDER}/" || echo "")
                
                if [[ -n "$PROVIDER_DEPRECATED_FILES" ]]; then
                  # Set provider display name
                  case "$PROVIDER" in
                    capa)
                      DISPLAY_NAME="CAPA"
                      ;;
                    azure)
                      DISPLAY_NAME="CAPZ"
                      ;;
                    vsphere)
                      DISPLAY_NAME="CAPV"
                      ;;
                    cloud-director)
                      DISPLAY_NAME="CAPVCD"
                      ;;
                    *)
                      DISPLAY_NAME=$(echo "$PROVIDER" | tr '[:lower:]' '[:upper:]')
                      ;;
                  esac
                  
                  PR_BODY="${PR_BODY}#### ${DISPLAY_NAME}\n\n"
                  
                  # Extract versions from the DEPRECATED files and sort them
                  DEPRECATED_VERSIONS=$(echo "$PROVIDER_DEPRECATED_FILES" | sed -E 's|.*/v([0-9]+\.[0-9]+\.[0-9]+.*)/release.yaml|\1|' | sort -V)

                  # Extract major versions from the DEPRECATED files and make them unique
                  MAJOR_VERSIONS_WITH_DEPRECATIONS=$(echo "$DEPRECATED_VERSIONS" | sed -E 's|^([0-9]+)\..*|\1|' | sort -n | uniq)

                  PR_BODY="${PR_BODY}\n| Major Version | Releases Deprecated |\n"
                  PR_BODY="${PR_BODY}|---------------|--------------------|\n"

                  for major in $MAJOR_VERSIONS_WITH_DEPRECATIONS; do
                    # Get all deprecated versions for this major version from the diff
                    DEPRECATED_IN_MAJOR_FROM_DIFF=$(echo "$DEPRECATED_VERSIONS" | grep -E "^${major}\." | sed 's/^/v/')

                    if [[ -n "$DEPRECATED_IN_MAJOR_FROM_DIFF" ]]; then
                      DEPRECATED_LIST_STR=$(echo "$DEPRECATED_IN_MAJOR_FROM_DIFF" | paste -sd "," - | sed 's/,/, /g')
                      PR_BODY="${PR_BODY}| v${major}         | ${DEPRECATED_LIST_STR} |\n"
                    fi
                  done
                  
                  PR_BODY="${PR_BODY}\n"
                fi
              done
            fi

            # Use EOF delimiter to handle multiline output
            echo "pr_body_changed_files_section<<EOF" >> $GITHUB_OUTPUT
            echo -e "$PR_BODY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "No release files were changed"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        if: ${{ steps.changed-files.outputs.has_changes == 'true' }}
        id: create-pr
        uses: peter-evans/create-pull-request@22a9089034f40e5a961c8808d113e2c98fb63676
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "CAPI: Deprecate outdated releases"
          title: "CAPI: Deprecate outdated releases"
          body: |
            ## Automated Release Deprecation for CAPI

            This PR automatically marks outdated releases across all CAPI providers as deprecated.
            A release is kept active if it meets any of the following criteria:

            - Currently in use
            - Latest of supported major versions
            - Required for upgrade path

            ${{ steps.changed-files.outputs.pr_body_changed_files_section }}

            ## Verify in Grafana

            You can check which releases are currently in use in the [CAPI Releases Dashboard](https://giantswarm.grafana.net/d/be9a0bh8mbwn4e/capi-releases?orgId=1&from=now-6h&to=now&timezone=browser).
          branch: auto-deprecate-capi-releases
          base: master
          labels: |
            release-maintenance
            automated

      - name: Post /skip-ci comment
        if: ${{ steps.changed-files.outputs.has_changes == 'true' && steps.create-pr.outputs.pull-request-number }}
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create-pr.outputs.pull-request-number }},
              body: '/skip-ci This change does not affect what\'s being tested by CI.'
            });
