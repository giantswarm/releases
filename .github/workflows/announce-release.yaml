name: Announce Release

on:
  workflow_dispatch:
    inputs:
      provider_all:
        description: 'Include all providers'
        required: false
        type: boolean
        default: false
      provider_capa:
        description: 'Include AWS (CAPA) provider'
        required: false
        type: boolean
        default: false
      provider_capz:
        description: 'Include Azure (CAPZ) provider'
        required: false
        type: boolean
        default: false
      provider_cloud_director:
        description: 'Include Cloud Director (CAPVCD) provider'
        required: false
        type: boolean
        default: false
      provider_eks:
        description: 'Include EKS provider'
        required: false
        type: boolean
        default: false
      provider_vsphere:
        description: 'Include vSphere (CAPV) provider'
        required: false
        type: boolean
        default: false
      provider_test:
        description: 'Test provider (for testing)'
        required: false
        type: boolean
        default: false
      channel:
        type: string
        description: 'Send the notification to a single specified channel (testing)'
        required: false
      version:
        type: string
        description: 'Semver formatted version for the announcement being made (e.g. v34.0.0)'
        required: true

jobs:
  gather_channels:
    name: Gather channels
    runs-on: ubuntu-latest
    outputs:
      provider_channels: ${{ steps.collect.outputs.provider_channels }}
    env:
      GH_TOKEN: ${{ secrets.ANNOUNCE_NOTIFY_TOKEN }}
    steps:
      - name: Checkout installations code
        uses: actions/checkout@v6
        with:
          repository: giantswarm/installations
          path: installations
          ref: master
          token: ${{ secrets.ANNOUNCE_NOTIFY_TOKEN }}
      - name: Collect channels
        id: collect
        run: |
          INPUT_CHANNEL="${{ inputs.channel }}"
          PROVIDERS_ALL="${{ inputs.provider_all }}"

          # Build list of selected providers
          SELECTED_PROVIDERS=()
          if [[ "$PROVIDERS_ALL" == "true" ]]; then
             # If 'all' is selected, include real providers (exclude test)
             SELECTED_PROVIDERS+=("capa" "capz" "cloud-director" "vsphere" "eks")
          else
             [[ "${{ inputs.provider_capa }}" == "true" ]] && SELECTED_PROVIDERS+=("capa")
             [[ "${{ inputs.provider_capz }}" == "true" ]] && SELECTED_PROVIDERS+=("capz")
             [[ "${{ inputs.provider_cloud_director }}" == "true" ]] && SELECTED_PROVIDERS+=("cloud-director")
             [[ "${{ inputs.provider_vsphere }}" == "true" ]] && SELECTED_PROVIDERS+=("vsphere")
             [[ "${{ inputs.provider_eks }}" == "true" ]] && SELECTED_PROVIDERS+=("eks")
             [[ "${{ inputs.provider_test }}" == "true" ]] && SELECTED_PROVIDERS+=("test")
          fi

          if [[ ${#SELECTED_PROVIDERS[@]} -eq 0 ]]; then
             echo "No providers selected"
             exit 1
          fi

          # Array to store provider-channel pairs
          declare -a provider_channel_pairs=()

          # If a specific channel is provided (for testing), pair it with each selected provider
          if [[ -n "$INPUT_CHANNEL" ]]; then
            for provider in "${SELECTED_PROVIDERS[@]}"; do
              provider_channel_pairs+=("{\"provider\":\"$provider\",\"channel\":\"$INPUT_CHANNEL\"}")
            done
            export OUTPUT=$(printf '%s\n' "${provider_channel_pairs[@]}" | jq -s -c .)
            echo "provider_channels=$OUTPUT" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Special handling for test provider
          if [[ " ${SELECTED_PROVIDERS[@]} " =~ " test " ]]; then
             provider_channel_pairs+=("{\"provider\":\"test\",\"channel\":\"test-capi-events\"}")
          fi

          # Process real providers
          for provider in "${SELECTED_PROVIDERS[@]}"; do
            if [[ "$provider" == "test" ]]; then
              continue  # Already handled above
            fi

            # Add default channels for each real provider
            provider_channel_pairs+=("{\"provider\":\"$provider\",\"channel\":\"noise-releases\"}")
            provider_channel_pairs+=("{\"provider\":\"$provider\",\"channel\":\"sig-product\"}")

            # Find installation-specific channels for this provider
            while read -r installation; do
              FILE_PATH="$installation/cluster.yaml"
              if [[ -f "$FILE_PATH" ]]; then
                INSTALLATION_PROVIDER=$(yq -r ".provider" $FILE_PATH)
                HAS_SLACK=$(yq 'has("slack")' $FILE_PATH)

                # Check if this installation matches current provider
                if [[ "$provider" == "$INSTALLATION_PROVIDER" ]]; then
                  if [[ "$HAS_SLACK" == "true" ]]; then
                    CHANNEL=$(yq -r '.slack.support[0]' "$FILE_PATH")
                    provider_channel_pairs+=("{\"provider\":\"$provider\",\"channel\":\"$CHANNEL\"}")
                  fi
                fi
              fi
            done < <(find ./installations -type d -mindepth 1 -maxdepth 1)
          done

          # Convert to JSON array and deduplicate
          export OUTPUT=$(printf '%s\n' "${provider_channel_pairs[@]}" | jq -s -c 'unique')
          echo "provider_channels=$OUTPUT" >> "$GITHUB_OUTPUT"
  
  get_announcement:
    name: Get announcement
    runs-on: ubuntu-latest
    outputs:
      announcements: ${{ steps.get_announcement_md.outputs.announcements }}
    steps:
      - name: Get announcement.md files
        id: get_announcement_md
        run: |
          # Build list of selected providers
          PROVIDERS_ALL="${{ inputs.provider_all }}"
          SELECTED_PROVIDERS=()

          if [[ "$PROVIDERS_ALL" == "true" ]]; then
             # If 'all' is selected, include real providers (exclude test)
             SELECTED_PROVIDERS+=("capa" "capz" "cloud-director" "vsphere" "eks")
          else
             [[ "${{ inputs.provider_capa }}" == "true" ]] && SELECTED_PROVIDERS+=("capa")
             [[ "${{ inputs.provider_capz }}" == "true" ]] && SELECTED_PROVIDERS+=("capz")
             [[ "${{ inputs.provider_cloud_director }}" == "true" ]] && SELECTED_PROVIDERS+=("cloud-director")
             [[ "${{ inputs.provider_vsphere }}" == "true" ]] && SELECTED_PROVIDERS+=("vsphere")
             [[ "${{ inputs.provider_eks }}" == "true" ]] && SELECTED_PROVIDERS+=("eks")
             [[ "${{ inputs.provider_test }}" == "true" ]] && SELECTED_PROVIDERS+=("test")
          fi

          if [[ ${#SELECTED_PROVIDERS[@]} -eq 0 ]]; then
             echo "No providers selected"
             exit 1
          fi

          # Fetch announcement for each provider and build JSON object
          declare -A announcements_map

          for PROVIDER in "${SELECTED_PROVIDERS[@]}"; do
            echo "Fetching announcement for provider: $PROVIDER"

            if [[ "$PROVIDER" == "test" ]]; then
              ANNOUNCEMENT_TEXT="This is a test announcement for version ${{ inputs.version }}"
            else
              # Map provider name to repo directory name
              REPO_DIR="$PROVIDER"
              if [[ "$PROVIDER" == "capz" ]]; then
                REPO_DIR="azure"
              fi

              LINK="https://raw.githubusercontent.com/giantswarm/releases/master/$REPO_DIR/${{ inputs.version }}/announcement.md"
              echo "Downloading from: $LINK"

              if wget -q "$LINK" -O "announcement_${PROVIDER}.md"; then
                ANNOUNCEMENT_TEXT=$(cat "announcement_${PROVIDER}.md")
              else
                echo "Failed to download announcement for $PROVIDER from $LINK"
                ANNOUNCEMENT_TEXT="Release announcement not available for $PROVIDER ${{ inputs.version }}"
              fi
            fi

            # Store in associative array
            announcements_map["$PROVIDER"]="$ANNOUNCEMENT_TEXT"
          done

          # Build JSON object from associative array
          echo "announcements<<EOF" >> "$GITHUB_OUTPUT"
          echo "{" >> "$GITHUB_OUTPUT"
          FIRST=true
          for PROVIDER in "${!announcements_map[@]}"; do
            if [[ "$FIRST" == "false" ]]; then
              echo "," >> "$GITHUB_OUTPUT"
            fi
            FIRST=false
            # Escape the announcement text for JSON
            ESCAPED=$(echo "${announcements_map[$PROVIDER]}" | jq -Rs .)
            echo "  \"$PROVIDER\": $ESCAPED" >> "$GITHUB_OUTPUT"
          done
          echo "" >> "$GITHUB_OUTPUT"
          echo "}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
  
  send_messages:
    name: Send Messages
    runs-on: ubuntu-latest
    needs: [gather_channels, get_announcement]
    strategy:
      matrix:
        include: ${{ fromJSON(needs.gather_channels.outputs.provider_channels) }}
    steps:
      - name: Extract announcement for provider
        id: get_provider_announcement
        run: |
          PROVIDER="${{ matrix.provider }}"
          ANNOUNCEMENTS='${{ needs.get_announcement.outputs.announcements }}'

          # Extract the announcement for this specific provider
          ANNOUNCEMENT=$(echo "$ANNOUNCEMENTS" | jq -r ".[\"$PROVIDER\"]")

          if [[ "$ANNOUNCEMENT" == "null" || -z "$ANNOUNCEMENT" ]]; then
            echo "No announcement found for provider: $PROVIDER"
            exit 1
          fi

          # Convert standard Markdown to Slack mrkdwn:
          #   **bold** -> *bold*
          #   [text](url) -> <url|text>
          ANNOUNCEMENT=$(echo "$ANNOUNCEMENT" | sed 's/\*\*\([^*]*\)\*\*/\*\1\*/g')
          ANNOUNCEMENT=$(echo "$ANNOUNCEMENT" | sed 's/\[\([^]]*\)\](\([^)]*\))/<\2|\1>/g')

          echo "announcement<<EOF" >> "$GITHUB_OUTPUT"
          echo "$ANNOUNCEMENT" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Write announcements
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            channel: ${{ matrix.channel }}
            text: ${{ toJSON(steps.get_provider_announcement.outputs.announcement) }}
            blocks:
              - type: "section"
                text:
                  type: "mrkdwn"
                  text: ${{ toJSON(steps.get_provider_announcement.outputs.announcement) }}
