# This workflow automatically archives deprecated releases on a schedule
# or when manually triggered. It includes validation to ensure that
# deprecated releases are not archived if they are still actively in use.

name: Archive Deprecated Releases

on:
  schedule:
    - cron: "0 10 * * 1" # Every Monday at 10:00 AM UTC

  # Allow manual triggering 
  workflow_dispatch:
  push:
    branches:
      - "master"
      - "main"
    paths:
      - ".github/workflows/archive-releases.yaml"
      - "azure/**"
      - "capa/**"
      - "cloud-director/**"
      - "eks/**"
      - "vsphere/**"

jobs:
  archive-releases:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
      
      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get provider lists
        id: providers
        uses: ./.github/actions/get-providers

      - name: Archive Deprecated Releases for All Providers
        id: archive_script
        run: |
          set -eo pipefail

          PROVIDERS="${{ steps.providers.outputs.provider_dirs }}"
          OVERALL_MOVED_RELEASES=""
          OVERALL_HAS_CHANGES=false

          for PROVIDER_ROOT_DIR in $PROVIDERS; do
            if [ ! -d "$PROVIDER_ROOT_DIR" ]; then
              echo "INFO: Provider directory $PROVIDER_ROOT_DIR not found. Skipping."
              continue
            fi

            echo "INFO: Processing provider directory: $PROVIDER_ROOT_DIR"

            MOVED_RELEASES_TEMP_FILE=$(mktemp)
            trap 'rm -f "$MOVED_RELEASES_TEMP_FILE"' EXIT

            find "$PROVIDER_ROOT_DIR" -maxdepth 1 -mindepth 1 -type d -name 'v*.*.*' -print0 | sort -z | while IFS= read -r -d $'\0' release_dir_path; do
              RELEASE_YAML_PATH="$release_dir_path/release.yaml"
              RELEASE_NAME=$(basename "$release_dir_path")

              if [ ! -f "$RELEASE_YAML_PATH" ]; then
                echo "WARNING: No release.yaml found in $release_dir_path. Skipping."
                continue
              fi

              if grep -q -E "^\s*state:\s*deprecated\s*$" "$RELEASE_YAML_PATH"; then
                echo "INFO: Release $RELEASE_NAME is deprecated"

                ARCHIVE_PARENT_DIR="$PROVIDER_ROOT_DIR/archived"
                ARCHIVED_RELEASE_FULL_PATH="$ARCHIVE_PARENT_DIR/$RELEASE_NAME"

                if [ -d "$ARCHIVED_RELEASE_FULL_PATH" ]; then
                  echo "INFO: Release $RELEASE_NAME is already archived. Skipping."
                  continue
                fi
                
                # Check if this release is safe to archive using Grafana metrics
                VERSION=$(echo "$RELEASE_NAME" | sed 's/^v//')
                
                # Use the existing validation script to check if it's safe
                echo "INFO: Checking if $PROVIDER_ROOT_DIR/$VERSION is safe to archive..."
                
                # Create archive directory if it doesn't exist
                if [ ! -d "$ARCHIVE_PARENT_DIR" ]; then
                  mkdir -p "$ARCHIVE_PARENT_DIR"
                fi
                
                # Create a temporary branch to simulate the move for validation
                TEMP_BRANCH="temp-validate-archive-$(date +%s%N)"
                CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
                
                # Create and switch to temporary branch
                git checkout -b "$TEMP_BRANCH"
                
                # Perform the move on the temporary branch
                git mv "$release_dir_path" "$ARCHIVED_RELEASE_FULL_PATH"
                git commit -m "Temporary: Test move of $RELEASE_NAME to archived"
                
                # Run the safety check (this will compare temp branch with origin/main)
                if ./tools/check-release-archive.sh "${{ secrets.GRAFANA_API_KEY }}"; then
                  echo "INFO: Release $RELEASE_NAME is safe to archive."
                  echo "$PROVIDER_ROOT_DIR:$RELEASE_NAME" >> "$MOVED_RELEASES_TEMP_FILE"
                else
                  echo "WARNING: Release $RELEASE_NAME is still in use and cannot be archived. Skipping."
                fi
                
                # Switch back to original branch and clean up
                git checkout "$CURRENT_BRANCH"
                git branch -D "$TEMP_BRANCH"
              fi
            done

            if [ -s "$MOVED_RELEASES_TEMP_FILE" ]; then
              echo "INFO: Moving all safe-to-archive releases for $PROVIDER_ROOT_DIR..."
              ARCHIVE_PARENT_DIR="$PROVIDER_ROOT_DIR/archived"
              # Use process substitution instead of pipe to avoid subshell
              while read -r release_entry; do
                PROVIDER_FROM_ENTRY=$(echo "$release_entry" | cut -d':' -f1)
                RELEASE_TO_MOVE=$(echo "$release_entry" | cut -d':' -f2)
                
                if [ "$PROVIDER_FROM_ENTRY" == "$PROVIDER_ROOT_DIR" ]; then
                  echo "INFO: Moving $RELEASE_TO_MOVE"
                  git mv "$PROVIDER_ROOT_DIR/$RELEASE_TO_MOVE" "$ARCHIVE_PARENT_DIR/$RELEASE_TO_MOVE"
                  OVERALL_MOVED_RELEASES="${OVERALL_MOVED_RELEASES}${PROVIDER_ROOT_DIR}:${RELEASE_TO_MOVE}\n"
                  OVERALL_HAS_CHANGES=true
                fi
              done < "$MOVED_RELEASES_TEMP_FILE"
            fi

            # Update kustomization.yaml if there were moves
            if [ -s "$MOVED_RELEASES_TEMP_FILE" ]; then
              KUSTOMIZATION_FILE="$PROVIDER_ROOT_DIR/kustomization.yaml"
              if [ -f "$KUSTOMIZATION_FILE" ]; then
                echo "INFO: Updating $KUSTOMIZATION_FILE"
                ORIG_KUSTOMIZATION_CONTENT=$(cat "$KUSTOMIZATION_FILE")
                NEW_KUSTOMIZATION_CONTENT="$ORIG_KUSTOMIZATION_CONTENT"

                TEMP_SED_SCRIPT_KUSTOMIZATION=$(mktemp)
                trap 'rm -f "$TEMP_SED_SCRIPT_KUSTOMIZATION"' EXIT

                while read -r release_entry; do
                  RELEASE_NAME=$(echo "$release_entry" | cut -d':' -f2)
                  echo "/^\s*-\s*${RELEASE_NAME}\s*$/d" >> "$TEMP_SED_SCRIPT_KUSTOMIZATION"
                done < "$MOVED_RELEASES_TEMP_FILE"

                if [ -s "$TEMP_SED_SCRIPT_KUSTOMIZATION" ]; then
                  NEW_KUSTOMIZATION_CONTENT=$(echo "$ORIG_KUSTOMIZATION_CONTENT" | sed -f "$TEMP_SED_SCRIPT_KUSTOMIZATION")

                  if [ $? -ne 0 ]; then
                    echo "ERROR: Failed to process kustomization.yaml"
                    exit 1
                  fi
                fi

                if [ "$NEW_KUSTOMIZATION_CONTENT" != "$ORIG_KUSTOMIZATION_CONTENT" ]; then
                  echo "$NEW_KUSTOMIZATION_CONTENT" > "$KUSTOMIZATION_FILE"
                  git add "$KUSTOMIZATION_FILE"
                  echo "INFO: $KUSTOMIZATION_FILE updated and staged."
                else
                  echo "INFO: No changes made to $KUSTOMIZATION_FILE."
                fi
              else
                echo "WARNING: $KUSTOMIZATION_FILE not found for provider $PROVIDER_ROOT_DIR."
              fi

              # Update README.md links
              README_FILE="README.md"
              if [ -f "$README_FILE" ]; then
                echo "INFO: Updating $README_FILE"
                ORIG_README_CONTENT=$(cat "$README_FILE")
                NEW_README_CONTENT="$ORIG_README_CONTENT"

                TEMP_SED_SCRIPT_README=$(mktemp)
                trap 'rm -f "$TEMP_SED_SCRIPT_README"' EXIT

                while read -r release_entry; do
                  RELEASE_NAME=$(echo "$release_entry" | cut -d':' -f2)
                  # Update GitHub links in README.md
                  OLD_GITHUB_PATH="tree/master/${PROVIDER_ROOT_DIR}/${RELEASE_NAME}"
                  NEW_GITHUB_PATH="tree/master/${PROVIDER_ROOT_DIR}/archived/${RELEASE_NAME}"
                  echo "s#${OLD_GITHUB_PATH}#${NEW_GITHUB_PATH}#g" >> "$TEMP_SED_SCRIPT_README"
                done < "$MOVED_RELEASES_TEMP_FILE"

                if [ -s "$TEMP_SED_SCRIPT_README" ]; then
                  NEW_README_CONTENT=$(echo "$ORIG_README_CONTENT" | sed -f "$TEMP_SED_SCRIPT_README")

                  if [ $? -ne 0 ]; then
                    echo "ERROR: Failed to process README.md with sed"
                    exit 1
                  fi
                fi

                if [ "$NEW_README_CONTENT" != "$ORIG_README_CONTENT" ]; then
                  echo "$NEW_README_CONTENT" > "$README_FILE"
                  git add "$README_FILE"
                  echo "INFO: $README_FILE updated and staged."
                else
                  echo "INFO: No changes made to $README_FILE."
                fi
              else
                echo "WARNING: $README_FILE not found."
              fi
            fi
          done

          # Generate PR body section
          if [ "$OVERALL_HAS_CHANGES" = true ]; then
            echo "has_archived_releases=true" >> $GITHUB_OUTPUT
            
            PR_BODY_SECTION="### Releases Archived in this PR\n\n"
            
            # Group by provider
            for PROVIDER in $PROVIDERS; do
              PROVIDER_ARCHIVES=$(echo -e "$OVERALL_MOVED_RELEASES" | grep "^${PROVIDER}:" || echo "")
              
              if [[ -n "$PROVIDER_ARCHIVES" ]]; then
                # Set provider display name
                case "$PROVIDER" in
                  capa)
                    DISPLAY_NAME="CAPA"
                    ;;
                  azure)
                    DISPLAY_NAME="CAPZ"
                    ;;
                  vsphere)
                    DISPLAY_NAME="CAPV"
                    ;;
                  cloud-director)
                    DISPLAY_NAME="CAPVCD"
                    ;;
                  *)
                    DISPLAY_NAME=$(echo "$PROVIDER" | tr '[:lower:]' '[:upper:]')
                    ;;
                esac
                
                PR_BODY_SECTION="${PR_BODY_SECTION}#### ${DISPLAY_NAME}\n\n"
                
                PR_BODY_SECTION="${PR_BODY_SECTION}\n| Major Version | Releases Archived |\n"
                PR_BODY_SECTION="${PR_BODY_SECTION}|---------------|-------------------|\n"
                
                # Extract versions from archived releases
                ARCHIVED_VERSIONS=$(echo -e "$PROVIDER_ARCHIVES" | cut -d':' -f2 | sed 's/^v//' | sort -V)
                MAJOR_VERSIONS_WITH_ARCHIVES=$(echo "$ARCHIVED_VERSIONS" | sed -E 's|^([0-9]+)\..*|\1|' | sort -n | uniq)
                
                for major in $MAJOR_VERSIONS_WITH_ARCHIVES; do
                  ARCHIVED_IN_MAJOR=$(echo "$ARCHIVED_VERSIONS" | grep -E "^${major}\." | sed 's/^/v/' | paste -sd "," - | sed 's/,/, /g')
                  if [ -n "$ARCHIVED_IN_MAJOR" ]; then
                    PR_BODY_SECTION="${PR_BODY_SECTION}| v${major}         | ${ARCHIVED_IN_MAJOR} |\n"
                  fi
                done
                
                PR_BODY_SECTION="${PR_BODY_SECTION}\n"
              fi
            done

            EOF_MARKER="END_OF_PR_BODY_SECTION_$(date +%s%N)"
            echo "archived_releases_pr_body_section<<$EOF_MARKER" >> $GITHUB_OUTPUT
            echo -e "$PR_BODY_SECTION" >> $GITHUB_OUTPUT
            echo "$EOF_MARKER" >> $GITHUB_OUTPUT
          else
            echo "has_archived_releases=false" >> $GITHUB_OUTPUT
            echo "archived_releases_pr_body_section=" >> $GITHUB_OUTPUT
          fi
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GRAFANA_API_KEY: ${{ secrets.GRAFANA_API_KEY }}

      - name: Create Pull Request
        if: steps.archive_script.outputs.has_archived_releases == 'true'
        id: create-pr
        uses: peter-evans/create-pull-request@22a9089034f40e5a961c8808d113e2c98fb63676
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "CAPI: Archive deprecated releases"
          title: "CAPI: Archive deprecated releases"
          body: |
            ## Automated Release Archiving for CAPI

            This PR archives deprecated releases across all CAPI providers.
            Archived releases are moved from `<provider>/<version>` to `<provider>/archived/<version>`.

            ${{ steps.archive_script.outputs.archived_releases_pr_body_section }}
          branch: auto-archive-capi-releases
          base: master
          labels: |
            release-maintenance
            automated
          delete-branch: true

      - name: Post /skip-ci comment
        if: steps.archive_script.outputs.has_archived_releases == 'true' && steps.create-pr.outputs.pull-request-number
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.create-pr.outputs.pull-request-number }},
              body: '/skip-ci This change does not affect what\'s being tested by CI.'
            });
